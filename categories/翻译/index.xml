<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>翻译 on 正小歪 BLOG</title><link>http://hexiangyu.me/categories/%E7%BF%BB%E8%AF%91/</link><description>Recent content in 翻译 on 正小歪 BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 12 May 2019 21:54:55 +0000</lastBuildDate><atom:link href="http://hexiangyu.me/categories/%E7%BF%BB%E8%AF%91/index.xml" rel="self" type="application/rss+xml"/><item><title>「译」Goroutine 泄露——被遗弃的接受者</title><link>http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/</link><pubDate>Sun, 12 May 2019 21:54:55 +0000</pubDate><guid>http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/</guid><description>&lt;p>&lt;a href="https://www.ardanlabs.com/blog/2018/12/goroutine-leaks-the-abandoned-receivers.html">原文地址&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。&lt;/p></description></item><item><title>「译」Goroutine 泄露——被遗忘的发送者</title><link>http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/</link><pubDate>Sun, 12 May 2019 21:54:37 +0000</pubDate><guid>http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。&lt;/p>
&lt;p>在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。&lt;/p></description></item><item><title>「译」在 Golang 中实现枚举类型</title><link>http://hexiangyu.me/posts/golang-enmu/</link><pubDate>Sun, 28 Apr 2019 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-enmu/</guid><description>&lt;p>&lt;a href="https://stein.wtf/posts/2019-04-16/enums/">原文地址&lt;/a>
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。&lt;/p>
&lt;p>这篇文章描述用于生成的 CLI，&lt;a href="https://github.com/steinfletcher/gonum">完全的原代码&lt;/a> 可以在 Github 上找到。&lt;/p></description></item><item><title>「译」Golang 使用高阶函数实现依赖注入</title><link>http://hexiangyu.me/posts/go-dependency-injection-md/</link><pubDate>Sun, 28 Apr 2019 00:13:33 +0000</pubDate><guid>http://hexiangyu.me/posts/go-dependency-injection-md/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://stein.wtf/posts/2019-03-12/inject/">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>你可以在 github.com/steinfletcher/func-dependency-injection-go 找到完整的代码。这个例子包含了一个完整的 REST 的 HTTP 服务器。&lt;/p></description></item><item><title>「译」在 Golang 中实现枚举类型</title><link>http://hexiangyu.me/posts/go-enums-md/</link><pubDate>Sun, 14 Apr 2019 00:03:17 +0000</pubDate><guid>http://hexiangyu.me/posts/go-enums-md/</guid><description>&lt;p>&lt;a href="https://stein.wtf/posts/2019-04-16/enums/">原文地址&lt;/a>
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。&lt;/p>
&lt;p>这篇文章描述用于生成的 CLI，&lt;a href="https://github.com/steinfletcher/gonum">完全的原代码&lt;/a> 可以在 Github 上找到。&lt;/p></description></item><item><title>「译」更详细的 Go 性能测试</title><link>http://hexiangyu.me/posts/golang-beachmark-details/</link><pubDate>Sun, 07 Apr 2019 20:33:27 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-beachmark-details/</guid><description>&lt;p>&lt;a href="https://medium.com/@egonelbre/benchmarking-with-details-1cf3e61d459d">原文连接&lt;/a>&lt;/p>
&lt;p>我一直在优化我的 go 代码并且一直优化我的性能测试方案。&lt;/p></description></item><item><title>「译」把项目从 Dep 迁移到 Go Modules</title><link>http://hexiangyu.me/posts/migrating-projects-from-dep-to-go-modules/</link><pubDate>Mon, 25 Mar 2019 22:46:31 +0000</pubDate><guid>http://hexiangyu.me/posts/migrating-projects-from-dep-to-go-modules/</guid><description>&lt;p>&lt;a href="http://elliot.land/post/migrating-projects-from-dep-to-go-modules">原文地址&lt;/a>&lt;/p>
&lt;p>Go Modules 是 Go 管理的未来方向。已经在 Go 1.11 中可以试用，将会是 Go 1.13 中的默认行为。&lt;/p>
&lt;p>我不会在这篇文章中描述包管理工具的工作流程。我会主要讨论的是如何把现有的项目中 dep 迁移的 Go Module。&lt;/p></description></item><item><title>「译」5 种方法构建安全的 Django Admin</title><link>http://hexiangyu.me/posts/5-ways-to-make-django-admin-safer/</link><pubDate>Sat, 17 Jun 2017 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/5-ways-to-make-django-admin-safer/</guid><description>&lt;p>&lt;a href="https://hackernoon.com/5-ways-to-make-django-admin-safer-eb7753698ac8">原文地址&lt;/a>&lt;/p>
&lt;p>拥有越大权限，往往也就责任也越大。Django Admin 在拥有修改权限的同时应该要更加注意安全。&lt;/p>
&lt;p>本文提供了 5 种方法来保护 Django Admin 避免来自认为的错误或者攻击者的攻击。&lt;/p></description></item><item><title>「译」Python 项目应该都有什么？</title><link>http://hexiangyu.me/posts/what-every-python-project-should-have/</link><pubDate>Mon, 30 Jan 2017 16:24:42 +0000</pubDate><guid>http://hexiangyu.me/posts/what-every-python-project-should-have/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://vladcalin.github.io/what-every-python-project-should-have.html#what-every-python-project-should-have">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Python 语言在过去的几年有着突飞猛进的发展，社区也在快速发展。在发展过程中，社区中出现了许多工具保持着资源的结构性和可获取性。在这篇文章中，我将提供一个简短列表，让每个 Python 项目中都具有可访问性和可维护性。&lt;/p></description></item><item><title>「译」Django 的 migtarion 冲突处理</title><link>http://hexiangyu.me/posts/django-migrations-and-how-to-manage-conflicts/</link><pubDate>Mon, 20 Jun 2016 16:51:24 +0000</pubDate><guid>http://hexiangyu.me/posts/django-migrations-and-how-to-manage-conflicts/</guid><description>&lt;p>Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。&lt;/p></description></item></channel></rss>