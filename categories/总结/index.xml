<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>总结 on 正小歪 BLOG</title><link>http://hexiangyu.me/categories/%E6%80%BB%E7%BB%93/</link><description>Recent content in 总结 on 正小歪 BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Apr 2021 16:10:01 +0000</lastBuildDate><atom:link href="http://hexiangyu.me/categories/%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ Primer 读书笔记</title><link>http://hexiangyu.me/posts/cpp-primer-learning/</link><pubDate>Fri, 30 Apr 2021 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/cpp-primer-learning/</guid><description>➡️ C++ Primer 读书笔记</description></item><item><title>数据库到底要不要外键</title><link>http://hexiangyu.me/posts/database-with-fk/</link><pubDate>Sun, 28 Apr 2019 16:09:34 +0000</pubDate><guid>http://hexiangyu.me/posts/database-with-fk/</guid><description>&lt;p>数据库的本质是存储数据，在这个之上还要维护数据的完整性。在维护完整性数据库提供几种方法，一种是事务，一种是外键 FK。这两种方式是分别处理两种情况，事务处理的是多个表中记录的原子性，FK 是处理多条有关系的记录。&lt;/p></description></item><item><title>MySQL 排序机制</title><link>http://hexiangyu.me/posts/mysql-order-by-md/</link><pubDate>Sun, 21 Apr 2019 00:10:07 +0000</pubDate><guid>http://hexiangyu.me/posts/mysql-order-by-md/</guid><description>&lt;p>在 MySQL 中经常使用 Order by 对数据进行排序，其实排序这个行为是比较消耗 IO 的过程，有时候需要回表多次才可以完成排序，所以在任何时候都需要对排序的原理要心知肚明。&lt;/p>
&lt;p>在 MySQL 中排序按照是否使用外部存储可以分为，内存排序和外部排序两种。根据排序所需的字段可以分成 rowid 排序和全字段排序两种。&lt;/p>
&lt;p>在 MySQL 执行排序的时候会分配一块内存 sort_buffer，MySQL 把需要排序的字段放入这个 sort_buffer 中，让，后在 sort_buffer 执行排序的过程，如果 sort_buffer 大小不够，就要使用外部存储。&lt;/p></description></item><item><title>CGroups 控制进程资源</title><link>http://hexiangyu.me/posts/linux-cgroups-md/</link><pubDate>Sun, 14 Apr 2019 00:01:08 +0000</pubDate><guid>http://hexiangyu.me/posts/linux-cgroups-md/</guid><description>&lt;p>cgroups 是 Linux 内核中的一个功能，用来限制、控制分离一个进程的资源，比如 CPU、内存、IO 等。&lt;/p></description></item><item><title>Go 语言中 Namespace 用法</title><link>http://hexiangyu.me/posts/golang-namespace-usage/</link><pubDate>Sun, 07 Apr 2019 20:33:05 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-namespace-usage/</guid><description>&lt;p>总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。&lt;/p></description></item><item><title>使用 RMDBS 存储树结构数据</title><link>http://hexiangyu.me/posts/tree-datastruct-in-rmdbs/</link><pubDate>Mon, 25 Mar 2019 22:44:56 +0000</pubDate><guid>http://hexiangyu.me/posts/tree-datastruct-in-rmdbs/</guid><description>&lt;p>在关系型数据库中存储树形结构是比较麻烦的事情，因为数据库都是基于行存储的结构，要满足树形数据结构的添加、删除、查询、修改是一件比较棘手的事情。&lt;/p></description></item><item><title>递归</title><link>http://hexiangyu.me/posts/recursive/</link><pubDate>Sat, 30 Jun 2018 19:26:18 +0000</pubDate><guid>http://hexiangyu.me/posts/recursive/</guid><description>&lt;p>递归（recursion）是数学中处理问题的一种常用方法，在计算机科学中指的是一种通过重复将问题分解为同类的子问题而解决问题的方法。&lt;/p>
&lt;p>换句话说，在处理分治问题上采用递归是一种很简单的方法，其强大描述能力，可以把无限过程表达在有限语句中。&lt;/p></description></item><item><title>Python 如何传递运算表达式</title><link>http://hexiangyu.me/posts/pass-operation-expression/</link><pubDate>Mon, 02 Apr 2018 23:54:25 +0000</pubDate><guid>http://hexiangyu.me/posts/pass-operation-expression/</guid><description>&lt;p>首先要说明的一下，所描述的是 Python 中的 &lt;strong>运算表达式&lt;/strong> 的部分，不是 Python 表达式的部分。&lt;/p>
&lt;p>关于什么是 Python 中的运算表达式，可以参考 Python 文档 &lt;a href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions">10.3.1. Mapping Operators to Functions&lt;/a> 部分，所需要传递的就是这部分运算表达式。&lt;/p></description></item><item><title>Python 优雅地 dumps 非标准类型</title><link>http://hexiangyu.me/posts/python-json-encode/</link><pubDate>Sat, 11 Nov 2017 18:38:29 +0000</pubDate><guid>http://hexiangyu.me/posts/python-json-encode/</guid><description>&lt;p>在 Python 很经常做的一件事就是 Python 数据类型和 JSON 数据类型的转换。&lt;/p>
&lt;p>但是存在一个明显的问题，JSON 作为一种数据交换格式有固定的数据类型，但是 Python 作为编程语言除了内置的数据类型以为还能编写自定义的数据类型。&lt;/p></description></item><item><title>「震惊」你可能需要一个假的 Fetch API</title><link>http://hexiangyu.me/posts/hack-fetch/</link><pubDate>Wed, 29 Mar 2017 16:22:57 +0000</pubDate><guid>http://hexiangyu.me/posts/hack-fetch/</guid><description>&lt;p>Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。&lt;/p>
&lt;p>Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。&lt;/p>
&lt;p>首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。&lt;/p></description></item><item><title>真正的 Tornado 异步非阻塞</title><link>http://hexiangyu.me/posts/real-tornado-async-noblocking/</link><pubDate>Sun, 29 Jan 2017 16:26:41 +0000</pubDate><guid>http://hexiangyu.me/posts/real-tornado-async-noblocking/</guid><description>&lt;p>其中 &lt;strong>Tornado&lt;/strong> 的定义是 Web 框架和异步网络库，其中他具备有异步非阻塞能力，能解决他两个框架请求阻塞的问题，在需要并发能力时候就应该使用 &lt;strong>Tornado&lt;/strong>。&lt;/p>
&lt;p>但是在实际使用过程中很容易把 &lt;strong>Tornado&lt;/strong> 使用成异步阻塞框架，这样对比其他两大框架没有任何优势而言，本文就如何实现真正的异步非阻塞记录。&lt;/p></description></item><item><title>设计模式 —— 抽象工厂模式</title><link>http://hexiangyu.me/posts/abstract-factory-pattern/</link><pubDate>Sun, 18 Dec 2016 16:30:35 +0000</pubDate><guid>http://hexiangyu.me/posts/abstract-factory-pattern/</guid><description>&lt;p>抽象工厂模式的实质是提供「接口」，子类通过实现这些接口来定义具体的操作。&lt;/p>
&lt;p>这些通用的接口如同协议一样，协议本身定义了一系列方法去描述某个类，子类通过实现这些方法从而实现了该类。&lt;/p>
&lt;p>子类中不用关心这个类该是什么样子的，这些都有抽象类去定义，这就区分设计类和实现类两个过程，实现过程的解耦。&lt;/p></description></item><item><title>设计模式 —— 建造者模式</title><link>http://hexiangyu.me/posts/builder-pattern/</link><pubDate>Fri, 16 Dec 2016 16:28:58 +0000</pubDate><guid>http://hexiangyu.me/posts/builder-pattern/</guid><description>&lt;p>建造者模式（生成器模式、Buidler Pattern）和抽象工厂模式的目的都是用来创建复杂的对象，但是创建的过程是截然不同的。&lt;/p></description></item><item><title>设计模式 —— 工厂方法</title><link>http://hexiangyu.me/posts/factory-method-pattern/</link><pubDate>Sat, 03 Dec 2016 16:37:36 +0000</pubDate><guid>http://hexiangyu.me/posts/factory-method-pattern/</guid><description>&lt;p>工厂方法是处理不指定对象具体类型情况下创建对象的问题。&lt;/p>
&lt;blockquote>
&lt;p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p>
&lt;/blockquote></description></item><item><title>使用 JWT 让你的 RESTful API 更安全</title><link>http://hexiangyu.me/posts/protect-your-restful-api-by-jwt/</link><pubDate>Sat, 26 Nov 2016 16:46:42 +0000</pubDate><guid>http://hexiangyu.me/posts/protect-your-restful-api-by-jwt/</guid><description>&lt;p>传统的 cookie-session 机制可以保证的接口安全，在没有通过认证的情况下会跳转至登入界面或者调用失败。&lt;/p>
&lt;p>在如今 RESTful 化的 API 接口下，cookie-session 已经不能很好发挥其余热保护好你的 API 。&lt;/p>
&lt;p>更多的形式下采用的基于 Token 的验证机制，JWT 本质的也是一种 Token，但是其中又有些许不同。&lt;/p></description></item><item><title>Django 带数据迁移 Model</title><link>http://hexiangyu.me/posts/django-migrate-model-with-data/</link><pubDate>Wed, 01 Jun 2016 16:49:48 +0000</pubDate><guid>http://hexiangyu.me/posts/django-migrate-model-with-data/</guid><description>&lt;p>Django 的 Model 迁移默认是先删除改表然后在另一个地方创建表，这时候会删除老的表的数据，但是有时候需要带着数据迁移。&lt;/p></description></item><item><title>设计 RESTful API 指南</title><link>http://hexiangyu.me/posts/restful-api-design/</link><pubDate>Tue, 05 Jan 2016 16:53:23 +0000</pubDate><guid>http://hexiangyu.me/posts/restful-api-design/</guid><description>如今的 web 应用前后端相对的独立了，后端接收和返回一些交互数据，前后端也就这点联系了。。。
那么重点来了，其中的核心就是怎么交互更合理、更方便，更简单。
以前数据交互无非就是 SOAP 和 XML 两种形式，这两个东西写起来和HTML似的一堆标签，看了就恶心。牛逼的 JSON 能和操作字典一样操作数据，省时、省心、省力。所以 REST 使用 JSON 作为数据交互的标准是很合理的。
REST 的全称为 Representational State Transfer， 即是资源的表现层状态转化。作为一种协议而非标准，其强大的结构清晰、符合标准、易于理解、扩展方便的特点得到了广泛的使用。
REST的核心在于资源和转化，就是如何把资源进行转化，去设计API接口。一种资源例如 ** /image ** ，可以使用不同的 HTTP 方发对资源进行转化。HTTP 中有GET、POST、PUT、PATCH、DELETE、OPTION、HEAD等方法。利用这些方法对资源进行配置。
同一种资源 REST 设计中最核心莫过于同一种资源 。例如**/image**，在浏览器中可以通过www.domain.com/image访问该资源。
通过不同的请求方法实现增删改查
获取 通过GET方法获取图片:
GET www.domain.com/image 删除 通过DELETE方法删除图片
DELETE www.domain.com/image 添加 通过POST方法在数据库中添加一个图片:
POST www.domain.com/image Request (application/json) { &amp;#34;imageName&amp;#34; : &amp;#34;xxx.png&amp;#34;, &amp;#34;imageData&amp;#34; : &amp;#34;base64 Code&amp;#34; } Response 200 (application/json) { &amp;#34;imageId&amp;#34; : 1 } 修改 PATCH www.domain.com/image Request (application/json) { &amp;#34;imageId&amp;#34; : 1, &amp;#34;imageData&amp;#34; : &amp;#34;new base64 Code&amp;#34; } Response 200 (application/json) { &amp;#34;isOK&amp;#34; : true } URL设计 URL 作为互联网中对服务器的唯一入口，一个好的 URL 可以很明确定位出这个 URL 是干嘛用的。</description></item></channel></rss>