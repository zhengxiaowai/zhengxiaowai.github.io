<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on 正小歪 BLOG</title><link>http://hexiangyu.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on 正小歪 BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 12 May 2019 21:58:01 +0000</lastBuildDate><atom:link href="http://hexiangyu.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 标准库源码分析 namedtuple</title><link>http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/</link><pubDate>Sun, 12 May 2019 21:58:01 +0000</pubDate><guid>http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/</guid><description>&lt;p>&lt;code>namedtuple&lt;/code> 是一个简化 &lt;code>tuple&lt;/code> 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。&lt;/p>
&lt;p>命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。&lt;/p>
&lt;p>假如想计算两个点之间的距离根据定义：&lt;/p></description></item><item><title>Bottle 源码分析</title><link>http://hexiangyu.me/posts/bottle-source-analysis/</link><pubDate>Sun, 21 May 2017 16:20:12 +0000</pubDate><guid>http://hexiangyu.me/posts/bottle-source-analysis/</guid><description>&lt;p>Bottle 是一个快速，简单和轻量级的 WSGI 微型 Web 框架的 Python。它作为单个文件模块分发，除了 Python 标准库之外没有依赖关系。&lt;/p>
&lt;p>选择源码分析的版本是 Release 于 2009 年 7 月 11 日的 0.4.10 （这是我能找到的最早的发布版本了）。&lt;/p></description></item><item><title>namedtuple —— 使用字符串动态生成类</title><link>http://hexiangyu.me/posts/namedtuple-use-string-template/</link><pubDate>Thu, 08 Dec 2016 16:32:00 +0000</pubDate><guid>http://hexiangyu.me/posts/namedtuple-use-string-template/</guid><description>&lt;p>Python 中的 &lt;code>namedtuple&lt;/code> 是一个对 &lt;code>tuple&lt;/code> 的加强机制，返回一个具有命名字段的 &lt;code>tuple&lt;/code> 子类。&lt;/p></description></item><item><title>OrderedDict —— 双向循环列表的最佳实践</title><link>http://hexiangyu.me/posts/ordereddict-double-linked-list/</link><pubDate>Thu, 01 Dec 2016 16:41:26 +0000</pubDate><guid>http://hexiangyu.me/posts/ordereddict-double-linked-list/</guid><description>Python 字典插入操作是无序的，当需要一个有序的字典时需要使用 OrderedDict。
OrderedDict 是继承自 dict 的子类，它具有普通字典的一模一样操作（包括时间复杂度），同时在内部还维护一个 双向循环链表 作为有序化的基础。内部方法中除了，__getitem__, __len__, __contains__ 和 get 之外方法都是具有顺序的。
初始化递归结构和哨兵节点 def __init__(*args, **kwds): &amp;#39;&amp;#39;&amp;#39;初始化一个有序字典，这个签名方法和普通字典一样，但是关键子参数是不被推荐的， 这时候的插入将会是任意的。 &amp;#39;&amp;#39;&amp;#39; if not args: raise TypeError(&amp;#34;descriptor &amp;#39;__init__&amp;#39; of &amp;#39;OrderedDict&amp;#39; object &amp;#34; &amp;#34;needs an argument&amp;#34;) self = args[0] args = args[1:] if len(args) &amp;gt; 1: raise TypeError(&amp;#39;expected at most 1 arguments, got %d&amp;#39; % len(args)) try: self.__root except AttributeError: self.__root = root = [] # 哨兵节点 root[:] = [root, root, None] self.</description></item></channel></rss>