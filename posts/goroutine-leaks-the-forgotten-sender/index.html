<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>「译」Goroutine 泄露——被遗忘的发送者 - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="
原文地址

简介
并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。
在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.102.3"><meta property="og:title" content="「译」Goroutine 泄露——被遗忘的发送者"><meta property="og:description" content="
原文地址

简介
并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。
在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-12T21:54:37+00:00"><meta property="article:modified_time" content="2019-05-12T21:54:37+00:00"><meta itemprop=name content="「译」Goroutine 泄露——被遗忘的发送者"><meta itemprop=description content="
原文地址

简介
并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。
在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。"><meta itemprop=datePublished content="2019-05-12T21:54:37+00:00"><meta itemprop=dateModified content="2019-05-12T21:54:37+00:00"><meta itemprop=wordCount content="698"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="「译」Goroutine 泄露——被遗忘的发送者"><meta name=twitter:description content="
原文地址

简介
并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。
在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">「译」Goroutine 泄露——被遗忘的发送者</h1><div class="text-sm opacity-60"><time>May 12, 2019</time></div></header><section><blockquote><p><a href=https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html>原文地址</a></p></blockquote><h2 id=简介>简介</h2><p>并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。</p><p>在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。</p><p>我将在这篇文章中讨论 Goroutine 泄露带来的陷阱。</p><h2 id=goroutine-泄露>Goroutine 泄露</h2><p>在内存管理方面 Go 屏蔽了许多细节。Go 编译器使用 <a href=https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html>逃逸分析</a> 确定变量在内存中的位置，在运行时使用 <a href=https://blog.golang.org/ismmkeynote>GC</a> 来跟踪和管理堆的分配。虽然这些机制可以不能完全避免 <a href=https://en.wikipedia.org/wiki/Memory_leak>内存泄露</a>，但是极大的降低了发生的概率。</p><p>一种常见的内存泄露类型就是 Goroutine 泄露。如果你启动了一个你希望它终止但是它不会终止的 Goroutine，这时候它已经泄露了。它会一直存在程序的生命周期中，并且无法释放为 Goroutine 分配的内存，这也是 “<a href=https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop>Never start a goroutine without knowing how it will stop</a>” 建议的主要原因之一。</p><p>要说明基本的 Goroutine 泄露，看下面代码：</p><h3 id=listing-1>Listing 1</h3><p><a href=https://play.golang.org/p/dsu3PARM24K>https://play.golang.org/p/dsu3PARM24K</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>31</span> <span style=color:#75715e>// leak is a buggy function. It launches a goroutine that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>32</span> <span style=color:#75715e>// blocks receiving from a channel. Nothing will ever be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>33</span> <span style=color:#75715e>// sent on that channel and the channel is never closed so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>34</span> <span style=color:#75715e>// that goroutine will be blocked forever.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>35</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>leak</span>() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>36</span>     <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>37</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>38</span>     <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>39</span>         <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>40</span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;We received a value:&#34;</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span>     }()
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span> }
</span></span></code></pre></div><p>Listing 1 定义了一个函数命名为 <code>leak</code>。这个函数在第 36 行创建了一个通道，允许 Goroutines 传递整型数据。然后在 38 行创建了一个被阻塞的 Gotoutine，这是因为在 39 行一直在等待从 channel 中获取值。这个 Goroutine 一直在等待，但是 <code>leak</code> 函数返回了。程序的其他部分无法通过 channel 发送数据，Goroutine 在 39 行无限的等待，第 40 行的 <code>fmt.Println</code> 永远不会被调用。</p><p>在这个例子中，Goroutine 泄露很容易在 code review 中被发现。但是我无法列出 Goroutine 泄露的所有可能，但是这篇文章可以详细说可能遇到的一种 Goroutine 泄露：</p><h2 id=被遗忘发送者的泄露>被遗忘发送者的泄露</h2><p><strong>这个泄露的例子，将会看到被无限阻塞的 Goroutine，等待发送值到 channel 中</strong></p><p>程序根据一些搜索词找到一条记录然后打印出来，该程序围绕着一个名为 <code>search</code> 函数构建：</p><h3 id=listing-2>Listing 2</h3><p><a href=https://play.golang.org/p/o6_eMjxMVFv>https://play.golang.org/p/o6_eMjxMVFv</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>29</span> <span style=color:#75715e>// search simulates a function that finds a record based
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>30</span> <span style=color:#75715e>// on a search term. It takes 200ms to perform this work.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>31</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span><span style=color:#ae81ff>32</span>     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>200</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>33</span>     <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;some value&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>34</span> }
</span></span></code></pre></div><p><code>search</code> 函数在 Listing 2 的第 31 行，mock 了一个模拟在数据库中查询或者 web 调用的长耗时操作，这里硬编码成 200 ms。</p><p>该程序调用 <code>search</code> 函数在 Listing 3 中显示如下：</p><h3 id=listing-3>Listing 3</h3><p><a href=https://play.golang.org/p/o6_eMjxMVFv>https://play.golang.org/p/o6_eMjxMVFv</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#ae81ff>17</span> <span style=color:#75715e>// process is the work for the program. It finds a record
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>18</span> <span style=color:#75715e>// then prints it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>19</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>process</span>(<span style=color:#a6e22e>term</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>20</span>     <span style=color:#a6e22e>record</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>21</span>     <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>22</span>         <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>23</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>25</span>     <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Received:&#34;</span>, <span style=color:#a6e22e>record</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>26</span>     <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>27</span> }
</span></span></code></pre></div><p>在 Listing 3 的 19 行，定义了一个函数 <code>process</code>，这个函数接受一个 <code>string</code> 类型的参数作为搜索词。在 20 行，这个参数传入 <code>search</code> 函数返回一个结果或者错误。如果发生了错误，这个错误会在 22 行被返回，如果没有错误结果会在 25 行被打印出来。</p><p>对于某些应用程序，顺序调用搜索的延时是不能接受的。假设无法使搜索运行的更快，可以将 <code>process</code> 函数改成不由 <code>search</code> 函数影响的延迟。</p><p>为此可以使用 Goroutine，如下 Listing 4 所示。不幸的是，这是一次错误的尝试，造成了潜在的 Goroutine 泄露。</p><h3 id=listing-4>Listing 4</h3><p><a href=https://play.golang.org/p/m0DHuchgX0A>https://play.golang.org/p/m0DHuchgX0A</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>38</span> <span style=color:#75715e>// result wraps the return values from search. It allows us
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>39</span> <span style=color:#75715e>// to pass both values across a single channel.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>40</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span>     <span style=color:#a6e22e>record</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span>     <span style=color:#a6e22e>err</span>    <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>43</span> }
</span></span><span style=display:flex><span><span style=color:#ae81ff>44</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span> <span style=color:#75715e>// process is the work for the program. It finds a record
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>46</span> <span style=color:#75715e>// then prints it. It fails if it takes more than 100ms.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>47</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>process</span>(<span style=color:#a6e22e>term</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>48</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>49</span>     <span style=color:#75715e>// Create a context that will be canceled in 100ms.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>50</span>     <span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>51</span>     <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
</span></span><span style=display:flex><span><span style=color:#ae81ff>52</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>53</span>     <span style=color:#75715e>// Make a channel for the goroutine to report its result.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>54</span>     <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>55</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>56</span>     <span style=color:#75715e>// Launch a goroutine to find the record. Create a result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>57</span>     <span style=color:#75715e>// from the returned values to send through the channel.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>58</span>     <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>59</span>         <span style=color:#a6e22e>record</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>60</span>         <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>result</span>{<span style=color:#a6e22e>record</span>, <span style=color:#a6e22e>err</span>}
</span></span><span style=display:flex><span><span style=color:#ae81ff>61</span>     }()
</span></span><span style=display:flex><span><span style=color:#ae81ff>62</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>63</span>     <span style=color:#75715e>// Block waiting to either receive from the goroutine&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>64</span>     <span style=color:#75715e>// channel or for the context to be canceled.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>65</span>     <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>66</span>     <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span><span style=color:#ae81ff>67</span>         <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;search canceled&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>68</span>     <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
</span></span><span style=display:flex><span><span style=color:#ae81ff>69</span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>70</span>             <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>71</span>         }
</span></span><span style=display:flex><span><span style=color:#ae81ff>72</span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Received:&#34;</span>, <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>record</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>73</span>         <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>74</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>75</span> }
</span></span></code></pre></div><p>在 listing 4 的第 50 行，重写了 <code>process</code> 函数，创建了一个 <code>Context</code> 用于 100ms 后可以被 canceled。更多有关如何使用 <code>Context</code> 的内容可以参考 <a href=https://blog.golang.org/context>golang.org blog post</a>。</p><p>在 54 行，改程序创建了一个无缓冲的 channel，允许 Goroutine 通过这个 channel 传送 <code>result</code> 类型的数据。第 58 行到 61 行是一个匿名的 Goroutine 函数。这个 Goroutine 调用 <code>search</code> 函数，尝试通过 channel 发送它的返回值在第 60 行。</p><p>在第 66 行的 case 中接受来自 <code>ctx.Done()</code> 的 channel。这个部分会在 <code>Context</code> 被 cancled（超过 100 ms 的时间）时被执行，如果该部分被执行 <code>process</code> 函数返回一个错误说明放弃在 67 行等待的 <code>search</code> 函数。</p><p>另外在 68 行的 case 接收来自 <code>ch</code> channel 的值，把值赋给变量 <code>result</code>。实现的和之前一样，在 69 行和 70 行检查错误，如果没有错误在 72 行打印结果，然后返回 <code>nil</code> 表示成功。</p><p>这次重构设置了 <code>process</code> 函数等待 <code>search</code> 函数的最长时间，可是在这个实现中埋下了 Goroutine 泄露的隐患。考虑一下 Goroutine 在代码中的运行情况，在第 60 行往 channel 中发送，此 channel 会阻塞发送直到另一个 Goroutine 做</p><p>好接收的准备。在超时的情况下，接受者将会停止从 Goroutine 接受的等待，继续运行。这将导致 Goroutine 永远被阻塞直到一个新的接受者出现，当然这个永远不会发送，这就发生了 Goroutine 泄露。</p><h2 id=fix多一点空间>Fix：多一点空间</h2><p>解决这个泄露最简单的办法就是将 channel 从无缓存改成容量为 1 的缓存通道。</p><h3 id=listing-5>Listing 5</h3><p><a href=https://play.golang.org/p/u3xtQ48G3qK>https://play.golang.org/p/u3xtQ48G3qK</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>53</span>     <span style=color:#75715e>// Make a channel for the goroutine to report its result.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>54</span>     <span style=color:#75715e>// Give it capacity so sending doesn&#39;t block.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>55</span>     <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>result</span>, <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>现在 timeout 后，程序继续运行，搜索的 Goroutine 将结果发送到 channel 后返回。Goroutine 和 channel 的所占用的内存会很自然地被回收。</p><p>在 <a href=https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html>The Behavior of Channels</a> 中 William Kennedy 提供几个有关 channel 行为的几个例子，同时说明了它们其中的原理。文章中最后一个例子 Listing 10 也提到类似的超时例子。阅读这篇文章获得更多有关使用缓冲 channel 和合适的大小的建议。</p><h2 id=总结>总结</h2><p>虽然 Go 可以很容易使用 Goroutine，但是我们有责任更恰当的使用它们。在这篇文章中我举了一个错误使用 Goroutine 的例子。还有很多 Gotoutine 泄露的例子，以及在并发编程中还有可能碰到其他的陷阱。在以后的文章中，我将提供更多有关 Goroutine 泄漏和其他并发陷阱的例子。现在我会给你这个建议，任何时候你开始 Goroutine 你必须问自己：</p><ul><li>它什么时候会终止？</li><li>什么会阻止它终止？</li></ul><p><strong>并发是一种有用的工具，但必须谨慎使用。</strong></p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/><span class=mr-1.5>←</span><span>「译」Goroutine 泄露——被遗弃的接受者</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/golang-enmu/><span>「译」在 Golang 中实现枚举类型</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>