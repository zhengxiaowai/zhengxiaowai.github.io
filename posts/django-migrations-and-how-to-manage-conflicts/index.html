<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>「译」Django 的 migtarion 冲突处理 - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.107.0"><meta property="og:title" content="「译」Django 的 migtarion 冲突处理"><meta property="og:description" content="Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/django-migrations-and-how-to-manage-conflicts/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-06-20T16:51:24+00:00"><meta property="article:modified_time" content="2016-06-20T16:51:24+00:00"><meta itemprop=name content="「译」Django 的 migtarion 冲突处理"><meta itemprop=description content="Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。"><meta itemprop=datePublished content="2016-06-20T16:51:24+00:00"><meta itemprop=dateModified content="2016-06-20T16:51:24+00:00"><meta itemprop=wordCount content="626"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="「译」Django 的 migtarion 冲突处理"><meta name=twitter:description content="Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">「译」Django 的 migtarion 冲突处理</h1><div class="text-sm opacity-60"><time>Jun 20, 2016</time></div></header><section><p>Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。</p><p><strong>翻译自 Oana Ratiu 的《<a href=https://www.algotech.solutions/blog/python/django-migrations-and-how-to-manage-conflicts/>Django Migrations and How to Manage Conflicts</a>》</strong></p><p>我一直不能找到一些有价值的文章和文档，也许在某个地方，所有的方法都可以解决冲突。然而从来没有人在 Google 上仔细的搜索。在这些问题上我会尝试收集一些不同角度。主要的是，我会尝试去解释你可以在项目中找到的那些 migrations，如何解决 migration 的冲突，和一些数据迁移的。我会假定你是有 Django、Python 和 GIT 的使用经验。</p><p><a href=https://docs.djangoproject.com/en/1.9/topics/migrations/#module-django.db.migrations>在 Django 的文档中对 migrations 的简单定义</a>：</p><blockquote><p>Migrantion 是 Django 根据你的想法，改变 Model （添加字段、删除 Model 等）到数据库中的方法。它们大多数是自动的，但是你需要知道什么时候执行 migrations，执行它们时候，你可能会遇到的问题。</p></blockquote><p>无论你选择是的 PostgreSQL, MySQL 还是 SQLite，你都可以使用一套命令去管理数据库。我将会较多的谈论关于 <strong>makemigrations</strong> 命令，它会基于你对 Model 的改动，然后创建新的 migrations。还有就是 <strong>migrate</strong> 命令，它会使 migrations 生效，完成后使它们失效和列出它们状态。</p><h2 id=我的-migrations-在哪里>我的 migrations 在哪里？</h2><p>在你的工程中，你可以找到 migrations 文件（.py 的文件）在 migrations 的文件夹里。确保文件夹中有 <strong>__init__.py</strong> 这个文件，如果没有这个文件，那么还是没有效果。</p><p>在你的 settings 文件中每个已安装的 app，你都可以找到对应得 migration 文件。例如，你可以在**…/lib/python2.7/site-packages/django/contrib/auth/migrations** 找到 User 的 migration。</p><p>你可以在你的数据库中找到 <strong>django_migrations</strong> 表，它列出了已经生效的 migrations。这是为了在切换分支的时候产生不同的 migrations，让你忘记执行到了哪里。</p><pre tabindex=0><code>my_data=# select * from django_migrations;
 id |      app      |          name           |            applied            
----+---------------+-------------------------+-------------------------------
 .. |     ...       |          ...            |             ...             
 10 | myapp         | 0001_initial            | 2016-03-17 07:22:30.329448+00
 11 | myapp         | 0002_auto_20160316_0909 | 2016-03-17 07:22:30.956985+00
 12 | myapp         | 0003_auto_20160318_1345 | 2016-03-18 13:45:23.895839+00
 .. |     ...       |          ...            |             ...             
(16 rows)
 
my_data=#
</code></pre><h2 id=首先为什么要保存-migrations-在项目中>首先，为什么要保存 migrations 在项目中？</h2><p>也许你会说：为什么不在 Python / Django 的项目中 GIT-ignore 所有的 migrations，让每个开发者创建自己的 migration 文件？这样做可以避免掉一些不必要的操作。很好，这就是写这篇文章的一个理由。</p><p>在继续之前，我希望你把在每次改变 model 改变后生成的 migrations 提交并推送到你仓库。这样所有的开发者都会拥有一份相同的 migrations。我必须强调这一点。</p><p>为什么这是如此重要的？想象一下，如果没有 migrations 在你的项目中，团队里的每个成员都要在本地生成自己的 migrations 文件。然而，我的项目最终总会在产品环境下，部署的时候会创建初始化的 migration 同时还会 migrate 数据库。在之后的时间，如果 model 改变我还会重新部署一次，这样又会在产品服务器上生成新的 migration。 但是如果现在发生一些事情，难道我还要有第二台产品服务器？再次部署，创建新的 migration 文件然后 migrate 我的数据库。这样一来，第一台产品服务器就有两份 migration 文件，然而第二台产品服务器只有一份 migration 文件，这一个巨大矛盾。我不能截断任何数据库的改变和执行数据库回滚。从根本上来说，如果你想回滚数据库，那就只能在每个服务器上。</p><p>所以，请保证 migrations 在你的项目中。你也许会遭遇冲突，但是如果你想要你的数据库版本，活着想要回滚数据库，在你的生活中，做一个开发者比监测 migrations 容易的多。</p><h2 id=migration-冲突>Migration 冲突</h2><p>假设我们有一个 Django 的项目，一份初始化 migration，同时也使用 GIT。我们使用 GIT，所以我们使用分支。我们使用分支，所以在 并分支的时候可能有 migrations 的冲突。当然，在团队中应该知道每个人在做什么，避免修改相同的 models。团队合作是重要的，但是一个人不可能总是避免 migrations 的冲突。因此千万别吓坏了，然后删除数据库，我就是这样干了很多次。它们是可以被很简单的修复，为了做到这一点，我将会解释一些简单的例子，但是它们是很有用的方法。你可以在你需求上选择一个最好的。</p><p>我们需要一份数据库的初始化 migration（Django 将会比较任何一个 model 去初始化 migration，而不是当前的数据库状态），我们不需要手动的修改数据库。</p><p>假设，我们有一个 UserProfile 的 model 同时还有两个分支：</p><ul><li>分支1，一个开发者添加一个 &ldquo;address&rdquo; 的字段到 UserProfile Model 中，这样就有了 &ldquo;migration 0003_userprofile_address.py&rdquo;</li><li>分支2，我想添加一个 &ldquo;age&rdquo; 字段到 UserProfile Model 中，这样就有了 &ldquo;0003_userprofile_age.py&rdquo;</li></ul><p>我的分支是分支2，我想合并分支1到分支2，在执行 GIT merge 后，在分支2中不但有我的 migrations 还有从分支1中来的 &ldquo;0003_userprofile_address.py&rdquo;。那么问题来了，这两个 migration 文件都试图修改相同的 model，而且都是以 &ldquo;0003_&rdquo; 命名的。</p><p>这里有三种可用的解决方法。前面两种是我推荐的，但是劝告你最好避免是使用第三种方法。</p><h3 id=方法1使用--merge>方法1：使用 -merge</h3><p>无论何时，在你使用这个方法之前，这都是非常容易的，因为 Django 会自动合并。因此，如果你是有经验丰富的开发者，你事先会知道这种方法是会失败的。考虑到这个选项只对非常简单的 model 的变化非常有用。</p><p>那么，为了让 Django 合并你的 migrations，你应该遵循以下步骤：</p><ul><li>尝试执行 <strong>python manage.py migrate</strong> (在这个时候，Django 将会查看这些冲突，然后告诉你执行 <strong>python manage.py makemigrations –merge</strong></li><li>执行 <strong>python manage.py makemigrations –merge</strong>，migrations 将会自动被合并；你将会创建一个新的 migration 叫 <strong>0004_merge.py</strong> 被放在migrations 文件夹中。</li><li>执行 <strong>python manage.py migrate</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> python manage<span style=color:#f92672>.</span>py migrate
</span></span><span style=display:flex><span>CommandError: Conflicting migrations detected (<span style=color:#ae81ff>0003</span>_userprofile_age, <span style=color:#ae81ff>0003</span>_userprofile_address <span style=color:#f92672>in</span> myapp)<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>To fix them run <span style=color:#e6db74>&#39;python manage.py makemigrations --merge&#39;</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> python manage<span style=color:#f92672>.</span>py makemigrations <span style=color:#f92672>--</span>merge
</span></span><span style=display:flex><span>Merging berguiapp
</span></span><span style=display:flex><span>  Branch <span style=color:#ae81ff>0003</span>_userprofile_age
</span></span><span style=display:flex><span>    <span style=color:#f92672>-</span> Add field age to userprofile
</span></span><span style=display:flex><span>  Branch <span style=color:#ae81ff>0003</span>_userprofile_address
</span></span><span style=display:flex><span>    <span style=color:#f92672>-</span> Add field address to userprofile
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>Merging will only work <span style=color:#66d9ef>if</span> the operations printed above do <span style=color:#f92672>not</span> conflict
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> each other (working on different fields <span style=color:#f92672>or</span> models)
</span></span><span style=display:flex><span>Do you want to merge these migration branches<span style=color:#960050;background-color:#1e0010>?</span> [y<span style=color:#f92672>/</span>N] y
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>Created new merge migration <span style=color:#f92672>.../</span>migrations<span style=color:#f92672>/</span><span style=color:#ae81ff>0004</span>_merge<span style=color:#f92672>.</span>py
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> python manage<span style=color:#f92672>.</span>py migrate
</span></span><span style=display:flex><span>Operations to perform:
</span></span><span style=display:flex><span>  Synchronize unmigrated apps: <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  Apply all migrations: <span style=color:#f92672>...</span> myapp, <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>Synchronizing apps without migrations:
</span></span><span style=display:flex><span>  Creating tables<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  Installing custom SQL<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  Installing indexes<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>Running migrations:
</span></span><span style=display:flex><span>  Applying myapp<span style=color:#ae81ff>.0003</span>_userprofile_age<span style=color:#f92672>...</span> OK
</span></span><span style=display:flex><span>  Applying myapp<span style=color:#ae81ff>.0003</span>_userprofile_address<span style=color:#f92672>...</span> OK
</span></span><span style=display:flex><span>  Applying myapp<span style=color:#ae81ff>.0004</span>_merge<span style=color:#f92672>...</span> OK
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span>
</span></span></code></pre></div><p>请记住这条信息 &ldquo;Merging will only work if the operations printed above do not conflict with each other (working on different fields or models)"。如果有复杂的修改，那么Django的可能不会正确合并 migrations，你将需要使用另一种方法。</p><h3 id=方法2回滚然后再次合并>方法2：回滚然后再次合并</h3><p>若果是第一次失败，你应该选择这个方法，或者你不认同有这么多的 migration 文件在你应用程序中。（尽管 Django 允许多个 migration 文件在你的项目中）。</p><ul><li>使用 <code>python manage.py migrate myapp my_most_recent_common_migration</code> 在你的分支中回滚最近正常的 migration。</li><li>你也可以这么做：<ul><li>暂时移除你的 migration，执行 <code>python manage.py migrate</code>，再次添加你的 migration 然后执行 <code>python manage.py migrate</code>。如果你的 migrations 涉及到不同的 models，同时又要有不同的 migration 生成，你应该使用这个 case。</li><li>移除这两部分 migrations 同时执行 <code>python manage.py makemigrations</code> 和 <code>python manage.py migrate</code> 获得一个从 <strong>0003_userprofile_age.py</strong> 和 <strong>0003_userprofile_address.py</strong> 融合后的 migration。如果你想当前的改变只生成一个 migration， 同时只涉及到相同的 model，你应该使用这个 case。需要注意的是，如果这个 migration 在别的分支中也删除了，确保没有人拥有它和任何人都知道这个已经被删除。如果你删除了，同时有有人使用了，这会导致一些恶心的 BUG。应该遵循一个基本的原装：不要删除后者修改其他人使用的 migration。</li><li>把 migration &ldquo;0003_&rdquo; 改成 &ldquo;0004_"(这不是强制的，但是得可以这么做)，修改依赖属性指向 &ldquo;0003_&rdquo; migration 同时执行 <code>python manage.py migrate</code>。这个方案可以替代第一种方案，但是你不得不手动修改 migration 的依赖属性指向最新的一个。你更喜欢回滚然后重新创建 migration 或者你喜欢手动修改 migration ，这都带有浓重的个人色彩。就我个人而言我喜欢第一个。</li></ul></li></ul><p>执行下面这个 snippet 之前，我移除两个 migrations （考虑到这两个分支都是我创建并且没有别人使用，因此我也使用第二种方法解释以上的东西）</p><pre tabindex=0><code>$ python manage.py migrate myapp 0002_auto_20160316_0909
Operations to perform:
  Target specific migration: 0002_auto_20160316_0909, from myapp
Running migrations:
  Unapplying myapp.0003_userprofile_age... OK
$ python manage.py makemigrations
Migrations for &#39;myapp&#39;:
  0003_auto_20160318_1345.py:
    - Add field address to userprofile
    - Add field age to userprofile
$ python manage.py migrate
Operations to perform:
  Synchronize unmigrated apps: ...
  Apply all migrations: ... myapp, ...
Synchronizing apps without migrations:
  Creating tables...
  Installing custom SQL...
  Installing indexes...
Running migrations:
  Applying myapp.0003_auto_20160318_1345... OK
$ 
</code></pre><p>如果有来自分支1的 migration 在相同的地方做和修改，你应该要小心地决定哪些是需要保留的，然后重新 migration。</p><h3 id=方法3-手动修改-migrations>方法3: 手动修改 migrations</h3><p>这种情况是极少发生的，但是如果你真的到了无法选择的地步，阅读 Django 中 writing Django migrations 的文档（<a href=https://docs.djangoproject.com/en/1.9/howto/static-files/deployment/>英文</a> <a href=http://python.usyiyi.cn/django_182/howto/writing-migrations.html>中文</a>），可以让你快速熟悉 migration 的主要部分。</p><h2 id=数据迁移>数据迁移</h2><p>在一个项目中其中一个迁移必定是数据迁移。假如有那么一个需求，把一个 ManyToMany 的关系改变成 OneToMany 的关系或者要报一个表分成两个表，这样必然有生成一个 migration。但是数据发生了什么？我们仍然需要数据在当前的数据库中。这就体现了数据迁移带来的好处，你要写一个自定义的 migration，这些脚本会把在执行 <code>python manage.py migrate</code> 之后的表结构和你的数据关联起来。你数据将会在新的表中。</p><p>需要明确你的数据迁移需要依赖什么。这个依赖会涉及到最后生成的 migration （名字，或者更精确的），同时需要被开发者指定。但是如果我们在产品服务器中有不同的 migration 设定，需要在每台服务器上小心地做出相应地依赖设定。虽然这是无趣的，但是可以避免复杂的迁移机制。</p><p>在 fixture 和数据迁移中还是有一些不同。Fixtures 是导入一些默认的数据到数据库中，然而数据迁移是在数据库上改变一些数据。fixture 是一个放在 fixture 文件夹中的一个 JSON 文件，使用命令：<code>python manage.py laoddata myapp/fixtures/my_fixture.json</code> 导入。这种方法是把默认的一类对象放入数据库中。另一种方法是，在 migrations 的文件夹中的数据迁移是一个 migration 文件。你不能使用数据迁移添加新的条目到你的数据库中，你只能在数据库众包修改他们。</p><h2 id=结束>结束</h2><p>migrations 是一种很有用的数据库更新机制。当你使用 Django 和数据库工作时候，你必须考虑使用 migrations。</p><p>即使你不是一个后端程序员，或者你使用不同的框架，没有使用类似的机制，尝试去理解他们背后的逻辑。他们也许就不是你第一看见的那么复杂，所有的问题都可以被很好的解决。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/weapp-github/><span class=mr-1.5>←</span><span>玩玩微信小程序</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/django-migrate-model-with-data/><span>Django 带数据迁移 Model</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>