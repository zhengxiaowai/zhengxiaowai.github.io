<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>CMU 15-445/645 Lecture 6: Hash Tables - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="设计目标：
数据组织（Data Organization）：如何在内存或者 pages 中排布数据，需要存储什么信息可以支持高效的防访问 并发（Concurrrency）：如何确保在同一时间多线程的访问不会出现问题 Hash Table 实现了一个无序的关联数组来存储 key 和 value，使用 Hash 函数计算出要插入 key 的 offset，以此来找到要存储的 value。
空间复杂度：O(n) 操作复杂度： 平均：O(1) 最坏：O(n) 申请一个数组，每个元素都可以存储一个 key，通过 hash 计算出在数组中的 offset，数组中存储着指向 value 的指针。这里有一些必须要满足的假设：
每一个 key 都是唯一 不同的 key 存在不同的 hash 值 所以 Hash Table 的设计目标就有：
Hash Function：如何把一个 key 转化成一小段空间，一般是固定的 32 bit 或者 64 bit 的整数；在速度和碰撞率上做出取舍，更快意味着会出现更多冲突 Hash Schema：如何处理 hash 后 key 发生了冲突；在空间和处理 key 的方法上做取舍，如果空间很大 key 的冲突概率就很小，反之如果空间很小就需要有额外的方法处理 key Hash Function 输入任意的 key 返回一个整型的数字，在 DBMS 并不使用加密的 hash 函数，更关心的是更快速度和更低的碰撞率。"><meta name=author content="正小歪 BLOG"><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.111.3"><meta property="og:title" content="CMU 15-445/645 Lecture 6: Hash Tables"><meta property="og:description" content="设计目标：
数据组织（Data Organization）：如何在内存或者 pages 中排布数据，需要存储什么信息可以支持高效的防访问 并发（Concurrrency）：如何确保在同一时间多线程的访问不会出现问题 Hash Table 实现了一个无序的关联数组来存储 key 和 value，使用 Hash 函数计算出要插入 key 的 offset，以此来找到要存储的 value。
空间复杂度：O(n) 操作复杂度： 平均：O(1) 最坏：O(n) 申请一个数组，每个元素都可以存储一个 key，通过 hash 计算出在数组中的 offset，数组中存储着指向 value 的指针。这里有一些必须要满足的假设：
每一个 key 都是唯一 不同的 key 存在不同的 hash 值 所以 Hash Table 的设计目标就有：
Hash Function：如何把一个 key 转化成一小段空间，一般是固定的 32 bit 或者 64 bit 的整数；在速度和碰撞率上做出取舍，更快意味着会出现更多冲突 Hash Schema：如何处理 hash 后 key 发生了冲突；在空间和处理 key 的方法上做取舍，如果空间很大 key 的冲突概率就很小，反之如果空间很小就需要有额外的方法处理 key Hash Function 输入任意的 key 返回一个整型的数字，在 DBMS 并不使用加密的 hash 函数，更关心的是更快速度和更低的碰撞率。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/cmu-15-445-hash-table/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-23T08:19:16+08:00"><meta property="article:modified_time" content="2023-04-23T08:19:16+08:00"><meta itemprop=name content="CMU 15-445/645 Lecture 6: Hash Tables"><meta itemprop=description content="设计目标：
数据组织（Data Organization）：如何在内存或者 pages 中排布数据，需要存储什么信息可以支持高效的防访问 并发（Concurrrency）：如何确保在同一时间多线程的访问不会出现问题 Hash Table 实现了一个无序的关联数组来存储 key 和 value，使用 Hash 函数计算出要插入 key 的 offset，以此来找到要存储的 value。
空间复杂度：O(n) 操作复杂度： 平均：O(1) 最坏：O(n) 申请一个数组，每个元素都可以存储一个 key，通过 hash 计算出在数组中的 offset，数组中存储着指向 value 的指针。这里有一些必须要满足的假设：
每一个 key 都是唯一 不同的 key 存在不同的 hash 值 所以 Hash Table 的设计目标就有：
Hash Function：如何把一个 key 转化成一小段空间，一般是固定的 32 bit 或者 64 bit 的整数；在速度和碰撞率上做出取舍，更快意味着会出现更多冲突 Hash Schema：如何处理 hash 后 key 发生了冲突；在空间和处理 key 的方法上做取舍，如果空间很大 key 的冲突概率就很小，反之如果空间很小就需要有额外的方法处理 key Hash Function 输入任意的 key 返回一个整型的数字，在 DBMS 并不使用加密的 hash 函数，更关心的是更快速度和更低的碰撞率。"><meta itemprop=datePublished content="2023-04-23T08:19:16+08:00"><meta itemprop=dateModified content="2023-04-23T08:19:16+08:00"><meta itemprop=wordCount content="649"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="CMU 15-445/645 Lecture 6: Hash Tables"><meta name=twitter:description content="设计目标：
数据组织（Data Organization）：如何在内存或者 pages 中排布数据，需要存储什么信息可以支持高效的防访问 并发（Concurrrency）：如何确保在同一时间多线程的访问不会出现问题 Hash Table 实现了一个无序的关联数组来存储 key 和 value，使用 Hash 函数计算出要插入 key 的 offset，以此来找到要存储的 value。
空间复杂度：O(n) 操作复杂度： 平均：O(1) 最坏：O(n) 申请一个数组，每个元素都可以存储一个 key，通过 hash 计算出在数组中的 offset，数组中存储着指向 value 的指针。这里有一些必须要满足的假设：
每一个 key 都是唯一 不同的 key 存在不同的 hash 值 所以 Hash Table 的设计目标就有：
Hash Function：如何把一个 key 转化成一小段空间，一般是固定的 32 bit 或者 64 bit 的整数；在速度和碰撞率上做出取舍，更快意味着会出现更多冲突 Hash Schema：如何处理 hash 后 key 发生了冲突；在空间和处理 key 的方法上做取舍，如果空间很大 key 的冲突概率就很小，反之如果空间很小就需要有额外的方法处理 key Hash Function 输入任意的 key 返回一个整型的数字，在 DBMS 并不使用加密的 hash 函数，更关心的是更快速度和更低的碰撞率。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a><div class="btn-dark text-[0] ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-16 pb-24 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">CMU 15-445/645 Lecture 6: Hash Tables</h1><div class="text-sm opacity-60"><time>Apr 23, 2023</time></div></header><section><p>设计目标：</p><ul><li>数据组织（Data Organization）：如何在内存或者 pages 中排布数据，需要存储什么信息可以支持高效的防访问</li><li>并发（Concurrrency）：如何确保在同一时间多线程的访问不会出现问题</li></ul><p>Hash Table 实现了一个无序的关联数组来存储 key 和 value，使用 Hash 函数计算出要插入 key 的 offset，以此来找到要存储的 value。</p><ul><li>空间复杂度：O(n)</li><li>操作复杂度：<ul><li>平均：O(1)</li><li>最坏：O(n)</li></ul></li></ul><p>申请一个数组，每个元素都可以存储一个 key，通过 hash 计算出在数组中的 offset，数组中存储着指向 value 的指针。这里有一些必须要满足的假设：</p><ol><li>每一个 key 都是唯一</li><li>不同的 key 存在不同的 hash 值</li></ol><p>所以 Hash Table 的设计目标就有：</p><ol><li>Hash Function：如何把一个 key 转化成一小段空间，一般是固定的 32 bit 或者 64 bit 的整数；在速度和碰撞率上做出取舍，更快意味着会出现更多冲突</li><li>Hash Schema：如何处理 hash 后 key 发生了冲突；在空间和处理 key 的方法上做取舍，如果空间很大 key 的冲突概率就很小，反之如果空间很小就需要有额外的方法处理 key</li></ol><h1 id=hash-function>Hash Function</h1><p>输入任意的 key 返回一个整型的数字，在 DBMS 并不使用加密的 hash 函数，更关心的是更快速度和更低的碰撞率。</p><ul><li><p>CRC-64 (1975) → Used in networking for error detection.</p></li><li><p>MurmurHash (2008) → Designed to a fast, general purpose hash function.</p></li><li><p>Google CityHash (2011) → Designed to be faster for short keys (&lt;64 bytes).</p></li><li><p>Facebook XXHash (2012) → From the creator of zstd compression.</p></li><li><p>Google FarmHash (2014) → Newer version of CityHash with better collision rates.</p></li></ul><p>综合素质来看 XXHash 相比其他 hash 函数拥有更快的速度和更低碰撞率，XXHash 有最新的 XXHash3 版本应该在数据库系统中优先使用。</p><h1 id=static-hasing-schemes>Static Hasing Schemes</h1><p>静态 hash 都需要在使用前需要提前知道希望保存 key 的数量，当存满的时候需要扩容这时候会把第一个 hash table 中所有的 key 拷贝到新的 hash table 中，一般这么做代价很高</p><h2 id=linear-probe-hashing>Linear Probe Hashing</h2><p>解决碰撞的方式就是在 table 中寻找下一个空闲的 slot</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-005123.png alt=image-20230425085119563></p><p>图中 hash(E) 后发现自己位置上已经存在了 A 就沿着顺序往下找直到发现 D 后面有一个空闲的 slot</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-005327.png alt=image-20230425085326812></p><p>删除时候后同理，先找到了 A 的位置然后向下搜索匹配，发现 C 后删除</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-005503.png alt=image-20230425085502765></p><p>删除之后就出现了空洞，如果空洞存在下次在 Find(D) 时候定位了空洞会就会发现没有找到。是因为 D 的插入是由于 C 存在向下找到空 slot 后插入的，所以 D 的位置是根据 C 的位置的 offset 来决定。一旦 C 被删除造成了空洞，D 也随之无法找到。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-005838.png alt=image-20230425085837987></p><p>解决的方法之一就是采用墓碑机制，删除并不是真正删除，只是标记成墓碑。这使得在 Find(D) 的时候仍然可以发现这个 slot 被占用了然后接着向下寻找。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-010004.png alt=image-20230425090004112></p><p>另一种方式就是通过移动来填补空洞，既然 C 的位置已经被删除，那么把 D 及其以下的 slot 都往上移动，补齐空洞。</p><p>在实际中，更多采用的是墓碑机制而不是移动。移动虽然更可以更快的回收 slot 但是带来的问题也更多，移动 slot 需要花费更多的时间，而且移动时候也需要考虑环形 slot 头尾节点问题。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-04-25-011231.png alt=image-20230425091230610></p><p>在 hash table 中比如作为 primary index 的 key 是唯一的，但是有时候 key 也不一定是唯一。这时候一般有两种处理方式，一种是给每个 key 都保留一个 value list，第二种是存储冗余的 key 和 value。明显看出第二种方式会使用更多空间，因为 key 需要存储多份，但是在实际情况下第二种方式用的也会更多，因为更简单。</p><h2 id=robin-hood-hashing>Robin Hood Hashing</h2><p>线性 Hash 的一个变种，可以偷取 “富有” 的 Key 的 Slot 分给 “贫穷” 的 Key。</p><ul><li>每个 Key 跟踪自己与原有位置之间的 offset，offset 越大表示越 “贫穷”</li><li>当插入一个 Key 时候，如果第一个 Key 的 offset 比 第二个 Key 的 offset 更小，第一个 Key 的 Slot 会被占用</li></ul><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-10-003842.png alt></p><p>当插入 E 的时候，原本的 slot 中已经有一个 A，对比 A 的 offset 与自己的 offset 都是 0，不能占用。接着往下对比 C 发现 offset 都是 1，也不能占用。往下对比 D，此时 D 的 offset 是 1，E 的 offset 是 2，所以此时的 E 比 D 更 “贫穷”，可以占用 D 的位置。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-10-004239.png alt></p><p>E 把 D 的 slot 占用以后，D 继续往下寻找位置，发现是一个空的 Slot，便可以插入，此时 D 的 offset 变为 2。</p><h3 id=cuckoo-hashing>Cuckoo Hashing</h3><p>使用多个不同 Seed 的 Hash Table，一般在生产环境中是 2 个。</p><ul><li>当插入时候，检查每个 table 哪里有空闲的 slot</li><li>如果 table 没有空闲的 slot，逐出当前位置中的 key，重新 hash 到另一个位置</li></ul><p>查找的时间复杂度总是 O(1) 因为每个位置只 hash table 中检查一次。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-10-010522.png alt></p><p>当 Insert C 的时候发现两个 Hash Table 都没有可有插入 slot，假设此时占用 B 的位置，B 就会被逐出。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-10-010646.png alt=image-20230510090645914></p><p>逐出之后，使用 hash1 重新 hash 到另个 table 中，这个位置也不是一个空的 slot，B 把 A 的位置再次占用，A 又被逐出。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-10-010807.png alt=image-20230510090806485></p><p>再次使用另个 Hash Table 的 hash2，找到有一个空的 slot 可以插入，此时 A 就存在另一个 Hash Table 中。</p><h1 id=dynamic-hashing-schemes>Dynamic Hashing Schemes</h1><p>静态的 Hash Table 总是需要提前预知大致的数据量，如果用超了需要购进新的 Hash Table 来扩容或者缩容，就会涉及的数据的移动。</p><p>动态的 Hash Table 可以根据需要自动调整大小：</p><ul><li>Chained Hashing</li><li>Extendible Hashing</li><li>Linear Hasing</li></ul><h2 id=chained-hasing>Chained Hasing</h2><p>每个 slot 包含 buckets 的链表的 hash table，把相同 hash key 的元素放入同一 bucket 中来解决冲突。</p><ul><li>要确定元素是否存在，需要找到特定的 bucket 进行 scan</li><li>插入和删除本质与查询一致</li></ul><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-12-010139.png alt></p><h2 id=extendible-hashing>Extendible Hashing</h2><p>Chained Hasing 的方案明显的缺点就是一个 linked list 可能会无限增长，而 Extendible Hasing 不但可以让多个 slot 对应相同的 bucket chain，而且在面对 bucket 溢出的时候，可以只针对这个 bucket 做拆分，只移动少量的数据。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-004436.png alt></p><ul><li>slot Array：数组中存储者指向 bucket 的指针，有一个 global count 用作判断前 n 位与 bucket 的对应关系</li><li>Bucket：存储的单元，有 local count，表示使用 n 位可以定位该 bucket</li></ul><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005037.png alt=image-20230517085037001></p><p>Hash(A) = 01110&mldr; 根据 global count 判断前 2 位是 01 所以指向了第一个 bucket，在 bucket 中扫描找出 A。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005441.png alt=image-20230517085441826></p><p>同理 B 通过前两位判断出处于第二个 bucket 中，然后插入到最后。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005609.png alt=image-20230517085609379></p><p>此时要插入 C，通过 Hash(C) 发现应该插入第二个 bucket，但是此时 bucket 已经满了无法插入，需要扩容。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005713.png alt=image-20230517085712999></p><p>第一步提升 global count 为 3。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005743.png alt=image-20230517085742687></p><p>第二步根据 global count 重新生成 slot array，这步并不会由太大影响 slot array 本身只存储着一些指向 bucket 的指针，只需要加上 latch 后扩容重新写入这个过程很快。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-005936.png alt=image-20230517085936729></p><p>第三步，拆封那个将要溢出的 bucket，提升它们的 local count 为3，重新映射 slot 与 bucket 的关系。这里拆分只是那个溢出的 bucket 其他的数据不动，所以这个过程也是很快。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-010221.png alt=" "></p><p>最后插入 C 到拆分后的第三个 bucket。</p><h2 id=linear-hasing>Linear Hasing</h2><p>Extendible Hasing 虽然很好解决了无限插入的问题，但是在扩容时候需要对 slot array 加 latch 扩容，这就会导致些阻塞，如果 bucket 不断地 overflowed 就会影响性能。</p><p>Linear Hasing 在 Extendible Hasing 的基础上进一步解决了这个问题，但是带来了更复杂的操作。</p><ul><li>split pointer：指向下一个要被拆分的 bucket，当任何一个 bucket overflow，就拆分指向的 bucket，与 overflow 的 bucket 无关</li><li>multiple hash function：被 split 的 bucket 需要使用另一个 hash 函数来定位新的位置</li></ul><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-012212.png alt=image-20230517092212146></p><p>假如要插入 17，第一个 hash 发现要插入 slot 位 1 的 bucket，但是 bucket 发生了 overflow，采取 chained hasing 的做法，加入一个 linked bucket，存储 17，此时 split point 指向的是 slot 为 0 的 bucket，所以要对这个 bucket 拆分。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-012418.png alt=image-20230517092417589></p><p>拆分 slot 为 0 的 bucket，需要移动该 bucket 中的数据到新的 bucket 中，然后 split point 向下移动此时指向的是 slot 为 1 的位置。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-012745.png alt=image-20230517092745162></p><p>加入此时需要 Find 20，经过第一个 hash 后发现是处于 split point 之前的 slot，所以需要进行二次 hash，找到 slot 为 4 的位置，20 就存在该 bucket 中。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-013400.png alt=image-20230517093359425></p><p>插入时候需要考虑扩容问题，那么删除的时候也需要缩容问题，假如此时删除 20，经过上面描述的方法两次之后找到了 20 位于 slot 为 4 的 bucket 中，并把 20 删除，此时该 bucket 为空。</p><p><img src=https://b2.hexiangyu.me/file/zxyblogcdn/2023-05-17-013609.png alt=image-20230517093609074></p><p>删除该 bucket 与 slot，同时要把 split pointer 往回移动，同时删除第二个 hash 函数，相反地如果 split pointer 走完了一轮 slot array 那就重新来过删除第一个 hash 函数，生成第三个 hash 函数。</p><h1 id=总结>总结</h1><p>Hash 可以在 O(1) 的时间复杂度内快速地查找，但是缺点就是只能对精确的 key 查找，无法根据一些条件来模糊查找。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=http://hexiangyu.me/posts/cmu-15-445-buffer-pool/><span>CMU 15-445/645 Lecture 5: Buffer Pool</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a></footer></body></html>