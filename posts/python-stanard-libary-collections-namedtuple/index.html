<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Python 标准库源码分析 namedtuple - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="namedtuple 是一个简化 tuple 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。
命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。
假如想计算两个点之间的距离根据定义："><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.105.0"><meta property="og:title" content="Python 标准库源码分析 namedtuple"><meta property="og:description" content="namedtuple 是一个简化 tuple 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。
命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。
假如想计算两个点之间的距离根据定义："><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-12T21:58:01+00:00"><meta property="article:modified_time" content="2019-05-12T21:58:01+00:00"><meta itemprop=name content="Python 标准库源码分析 namedtuple"><meta itemprop=description content="namedtuple 是一个简化 tuple 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。
命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。
假如想计算两个点之间的距离根据定义："><meta itemprop=datePublished content="2019-05-12T21:58:01+00:00"><meta itemprop=dateModified content="2019-05-12T21:58:01+00:00"><meta itemprop=wordCount content="861"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 标准库源码分析 namedtuple"><meta name=twitter:description content="namedtuple 是一个简化 tuple 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。
命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。
假如想计算两个点之间的距离根据定义："></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">Python 标准库源码分析 namedtuple</h1><div class="text-sm opacity-60"><time>May 12, 2019</time></div></header><section><p><code>namedtuple</code> 是一个简化 <code>tuple</code> 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。</p><p>命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。</p><p>假如想计算两个点之间的距离根据定义：</p><p><img src=https://static.zhengxiaowai.cc/2019-05-12-135932.png alt></p><p>需要两个点的 x、y 坐标，我们可以直接使用元组表示 p1 和 p2 点</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> p1, p2 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>), (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> s <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>sqrt((p1[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> p2[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (p1[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p2[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(s)
</span></span><span style=display:flex><span><span style=color:#ae81ff>1.4142135623730951</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>对于 p1 点的 x 坐标使用 p1[0] 表示，对阅读上有一定的困扰，如果可以使用 <code>p1.x</code> 就语义清晰了。</p><p>这个场景就是 <code>namedtuple</code> 的典型应用，让字段具有名字，使用 <code>namedtuple</code> 重写上面例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> collections
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Point <span style=color:#f92672>=</span> collections<span style=color:#f92672>.</span>namedtuple(<span style=color:#e6db74>&#39;Point&#39;</span>, [<span style=color:#e6db74>&#39;x&#39;</span>, <span style=color:#e6db74>&#39;y&#39;</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> p1, p2 <span style=color:#f92672>=</span> Point(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>), Point(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> s <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>sqrt((p1<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> p2<span style=color:#f92672>.</span>x)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (p1<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> p2<span style=color:#f92672>.</span>y)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(s)
</span></span><span style=display:flex><span><span style=color:#ae81ff>1.4142135623730951</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>好奇宝宝肯定就会想知道 <code>namedtuple</code> 是如何让字段具有名字的，先看看函数的签名</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>namedtuple(typename, field_names, <span style=color:#f92672>*</span>, rename<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, defaults<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,module<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>)
</span></span></code></pre></div><p>第一个和第二参数前面已经使用过了，<code>typename</code> 就是新命名元组的名字，我们最经常的就是模仿的类，所以会使用类的定义风格。<code>field_names</code> 参数用于定义字段的名字，除了上面使用 <code>['x', 'y']</code> 还可以使用 <code>"x y"</code> 或者 <code>"x, y"</code>，定义方法选择自己喜欢的就好。</p><p><code>rename</code> 参数默认是 <code>False</code>，顾名思义就是重命名字段名字，假如我们使用了非法的变量名（比如关键字等）会被重命名成别的名字。</p><blockquote><p>[!DANGER]</p><p>这种改变定义的行为是最好不要做，除非你能保证任何人知道这个行为。</p></blockquote><p><code>defaults</code> 参数可以是 <code>None</code> 或者一个可迭代的值，根据具有默认值的字段必须在没有初始值的后面，所以<code>defaults</code> 提供的默认值都是最右匹配。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> namedtuple
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Point <span style=color:#f92672>=</span> namedtuple(<span style=color:#e6db74>&#39;Point&#39;</span>, <span style=color:#e6db74>&#34;x y z&#34;</span>, defaults<span style=color:#f92672>=</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> p1 <span style=color:#f92672>=</span> Point(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(p1)
</span></span><span style=display:flex><span>Point(x<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, y<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, z<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>如果定义了 <code>module</code>，则将命名元组的 <code>__module__ </code>属性设置为该值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> isinstance(field_names, str):
</span></span><span style=display:flex><span>        field_names <span style=color:#f92672>=</span> field_names<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#e6db74>&#39; &#39;</span>)<span style=color:#f92672>.</span>split()
</span></span><span style=display:flex><span>    field_names <span style=color:#f92672>=</span> list(map(str, field_names))
</span></span><span style=display:flex><span>    typename <span style=color:#f92672>=</span> _sys<span style=color:#f92672>.</span>intern(str(typename))
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>进入函数的第一步先对两个基本的参数 <code>typename</code> 和 <code>field_names</code> 进行处理。</p><p>如果 <code>field_names</code> 是一个字符串就 replace 把 <code>,</code> 转化成空格，再 split 成标准的 list。 <code>list(map(str, field_names))</code> 保证了 <code>field_names</code> 的每个值都是 str 类型。
<code>_sys.intern</code> 把 typename 注册到全局中，可以加快对字符串的寻找。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> rename:
</span></span><span style=display:flex><span>        seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index, name <span style=color:#f92672>in</span> enumerate(field_names):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>not</span> name<span style=color:#f92672>.</span>isidentifier()
</span></span><span style=display:flex><span>                <span style=color:#f92672>or</span> _iskeyword(name)
</span></span><span style=display:flex><span>                <span style=color:#f92672>or</span> name<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;_&#39;</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>or</span> name <span style=color:#f92672>in</span> seen):
</span></span><span style=display:flex><span>                field_names[index] <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;_</span><span style=color:#e6db74>{</span>index<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>            seen<span style=color:#f92672>.</span>add(name)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>对于设置了 <code>rename=True</code> 会对不合法的 field_name 重新命名，从代码中可以看出重新命名的规则是：如果不合法，判断是不是 <strong>关键字</strong>、是不是以 <strong>下划线</strong> 开头，是不是 <strong>已经存在</strong>，如果符合其中一项就会对用 <code>_{当前的 index}</code>变量重新命名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> [typename] <span style=color:#f92672>+</span> field_names:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> type(name) <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> str:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#e6db74>&#39;Type names and field names must be strings&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> name<span style=color:#f92672>.</span>isidentifier():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;Type names and field names must be valid &#39;</span>
</span></span><span style=display:flex><span>                             <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;identifiers: </span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>!r}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> _iskeyword(name):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;Type names and field names cannot be a &#39;</span>
</span></span><span style=display:flex><span>                             <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;keyword: </span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>!r}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> field_names:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> name<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;_&#39;</span>) <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> rename:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;Field names cannot start with an underscore: &#39;</span>
</span></span><span style=display:flex><span>                             <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>!r}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> name <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Encountered duplicate field name: </span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>!r}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        seen<span style=color:#f92672>.</span>add(name)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>接下来对输入的 typename 和 field_names 经检查了一下参数，仍是使用上面的三个规则，确保 typename 和 field_names 中的元素是合法的字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    field_defaults <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> defaults <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        defaults <span style=color:#f92672>=</span> tuple(defaults)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(defaults) <span style=color:#f92672>&gt;</span> len(field_names):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#e6db74>&#39;Got more default values than field names&#39;</span>)
</span></span><span style=display:flex><span>        field_defaults <span style=color:#f92672>=</span> dict(reversed(list(zip(reversed(field_names),
</span></span><span style=display:flex><span>                                                reversed(defaults)))))
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>如果设置了 defaults 参数，要最右匹配到 field_names。先使用了 <code>zip</code> 函数，把 <code>reversed</code> 后的 field_names 和 defaults 组合成元组的 list</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> field_names <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;x&#39;</span>, <span style=color:#e6db74>&#39;y&#39;</span>, <span style=color:#e6db74>&#39;z&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> defaults <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(list(zip(reversed(field_names), reversed(defaults))))
</span></span><span style=display:flex><span>[(<span style=color:#e6db74>&#39;z&#39;</span>, <span style=color:#ae81ff>3</span>), (<span style=color:#e6db74>&#39;y&#39;</span>, <span style=color:#ae81ff>2</span>)]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>最后在使用 <code>dict(reversed(...))</code> 转化成 dict 类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Variables used in the methods and docstrings</span>
</span></span><span style=display:flex><span>    field_names <span style=color:#f92672>=</span> tuple(map(_sys<span style=color:#f92672>.</span>intern, field_names))
</span></span><span style=display:flex><span>    num_fields <span style=color:#f92672>=</span> len(field_names)
</span></span><span style=display:flex><span>    arg_list <span style=color:#f92672>=</span> repr(field_names)<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;&#39;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    repr_fmt <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;(&#39;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;, &#39;</span><span style=color:#f92672>.</span>join(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>=%r&#39;</span> <span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> field_names) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;)&#39;</span>
</span></span><span style=display:flex><span>    tuple_new <span style=color:#f92672>=</span> tuple<span style=color:#f92672>.</span>__new__
</span></span><span style=display:flex><span>    _dict, _tuple, _len, _map, _zip <span style=color:#f92672>=</span> dict, tuple, len, map, zip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create all the named tuple methods to be added to the class namespace</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;def __new__(_cls, </span><span style=color:#e6db74>{</span>arg_list<span style=color:#e6db74>}</span><span style=color:#e6db74>): return _tuple_new(_cls, (</span><span style=color:#e6db74>{</span>arg_list<span style=color:#e6db74>}</span><span style=color:#e6db74>))&#39;</span>
</span></span><span style=display:flex><span>    namespace <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;_tuple_new&#39;</span>: tuple_new, <span style=color:#e6db74>&#39;__name__&#39;</span>: <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;namedtuple_</span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>}
</span></span><span style=display:flex><span>    <span style=color:#75715e># Note: exec() has the side-effect of interning the field names</span>
</span></span><span style=display:flex><span>    exec(s, namespace)
</span></span><span style=display:flex><span>    __new__ <span style=color:#f92672>=</span> namespace[<span style=color:#e6db74>&#39;__new__&#39;</span>]
</span></span><span style=display:flex><span>    __new__<span style=color:#f92672>.</span>__doc__ <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Create new instance of </span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>{</span>arg_list<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> defaults <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        __new__<span style=color:#f92672>.</span>__defaults__ <span style=color:#f92672>=</span> defaults
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>这部分动态设置参数的过程，重点关注 <code>exec(s, namespace)</code> ，s 是 <code>__new__</code> 方法的定义，其中的 <code>arg_list</code> 是我们设置的属性名字会转换成 <code>x, y, x</code> 这种形式，填充的 s 中。namespace 则是 exec 过程中可使用的变量，这里传入了 <code>tuple_new = tuple.__new__</code> 用于创建一个新的 tuple。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_make</span>(cls, iterable):
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> tuple_new(cls, iterable)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> _len(result) <span style=color:#f92672>!=</span> num_fields:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Expected </span><span style=color:#e6db74>{</span>num_fields<span style=color:#e6db74>}</span><span style=color:#e6db74> arguments, got </span><span style=color:#e6db74>{</span>len(result)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _make<span style=color:#f92672>.</span>__func__<span style=color:#f92672>.</span>__doc__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Make a new </span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74> object from a sequence &#39;</span>
</span></span><span style=display:flex><span>                              <span style=color:#e6db74>&#39;or iterable&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_replace</span>(_self, <span style=color:#f92672>**</span>kwds):
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> _self<span style=color:#f92672>.</span>_make(_map(kwds<span style=color:#f92672>.</span>pop, field_names, _self))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> kwds:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Got unexpected field names: </span><span style=color:#e6db74>{</span>list(kwds)<span style=color:#e6db74>!r}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _replace<span style=color:#f92672>.</span>__doc__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Return a new </span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74> object replacing specified &#39;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;fields with new values&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Return a nicely formatted representation string&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__class__<span style=color:#f92672>.</span>__name__ <span style=color:#f92672>+</span> repr_fmt <span style=color:#f92672>%</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_asdict</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Return a new dict which maps field names to their values.&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _dict(_zip(self<span style=color:#f92672>.</span>_fields, self))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__getnewargs__</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Return self as a plain tuple.  Used by copy and pickle.&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _tuple(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Modify function metadata to help with introspection and debugging</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> method <span style=color:#f92672>in</span> (__new__, _make<span style=color:#f92672>.</span>__func__, _replace,
</span></span><span style=display:flex><span>                   __repr__, _asdict, __getnewargs__):
</span></span><span style=display:flex><span>        method<span style=color:#f92672>.</span>__qualname__ <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74>.</span><span style=color:#e6db74>{</span>method<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>接着定义了一些列的方法，这些方法最后都是用于生成 namedtuple 后所拥有的方法，根据简单的注释可以很容易知道他们的用途</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Build-up the class namespace dictionary</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># and use type() to build the result class</span>
</span></span><span style=display:flex><span>    class_namespace <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;__doc__&#39;</span>: <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>typename<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>{</span>arg_list<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;__slots__&#39;</span>: (),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_fields&#39;</span>: field_names,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_field_defaults&#39;</span>: field_defaults,
</span></span><span style=display:flex><span>        <span style=color:#75715e># alternate spelling for backward compatiblity</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_fields_defaults&#39;</span>: field_defaults,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;__new__&#39;</span>: __new__,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_make&#39;</span>: _make,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_replace&#39;</span>: _replace,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;__repr__&#39;</span>: __repr__,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;_asdict&#39;</span>: _asdict,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;__getnewargs__&#39;</span>: __getnewargs__,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># _tuplegetter = lambda index, doc: property(_itemgetter(index), doc=doc)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> index, name <span style=color:#f92672>in</span> enumerate(field_names):
</span></span><span style=display:flex><span>        doc <span style=color:#f92672>=</span> _sys<span style=color:#f92672>.</span>intern(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Alias for field number </span><span style=color:#e6db74>{</span>index<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        class_namespace[name] <span style=color:#f92672>=</span> _tuplegetter(index, doc)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> type(typename, (tuple,), class_namespace)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>定义 <code>class_namespace</code> 传入上面定义好一系列方法，最后使用 <code>type</code> 创建出一个新的 class。</p><blockquote><p>[!NOTE]</p><p>Python 所有的东西都是 type 这个函数创建出来的，包括 type 本身，更多 type 相关信息参考
<a href=https://docs.python.org/3/library/functions.html#type>https://docs.python.org/3/library/functions.html#type</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># For pickling to work, the __module__ variable needs to be set to the frame</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># where the named tuple is created.  Bypass this step in environments where</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># sys._getframe is not defined (Jython for example) or sys._getframe is not</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># defined for arguments greater than 0 (IronPython), or where the user has</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># specified a particular module.</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> module <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>           module <span style=color:#f92672>=</span> _sys<span style=color:#f92672>.</span>_getframe(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>f_globals<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;__name__&#39;</span>, <span style=color:#e6db74>&#39;__main__&#39;</span>)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>except</span> (<span style=color:#a6e22e>AttributeError</span>, <span style=color:#a6e22e>ValueError</span>):
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> module <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>       result<span style=color:#f92672>.</span>__module__ <span style=color:#f92672>=</span> module
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>最后需要把 module 属性设置回 result 的 <code>__module__</code> 中，这些信息会在 pickle 会被用到。</p><p>总结一下，namedtuple 创建过程大体分成三个部分：</p><ol><li>提取参数、定义 tuple 所需的方法</li><li>根据参数名字动态构建 <code>__new__</code> 函数，和最后生成的 tuple 的属性可以对应上</li><li>填充 class_namespace，用 <code>type</code> 函数创建一个 tuple 对象</li></ol><p>其实在不久之前，namedtuple 还是直接使用字符串模板生成，现在这种实现方法更优雅了。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/cpp-primer-learning/><span class=mr-1.5>←</span><span>C++ Primer 读书笔记</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/><span>「译」Goroutine 泄露——被遗弃的接受者</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>