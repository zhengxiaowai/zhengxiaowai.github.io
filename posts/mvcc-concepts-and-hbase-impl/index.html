<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>MVCC Concepts and HBase Implementation - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="Multi-Version Concurrency Control 包含两个部分：
Multi-Version：存储多个版本数据，使得读写可以不冲突 Concurrency Control：并发控制，使执行过程可串行化 数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。
T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) BEGIBN W(A) A0 123 0 2 A1 456 2 - R(A) COMMIT COMMIT 初始版本为 A0，值为 123，可见范围是 0 ～ ∞ T1 的 R(A) 因为 0 < 1 < ∞，读取的值为 123 T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2 T1 的第二次 R(A) 因为 0 < 1 < 2(A0 版本的 End 是 2)，读取的值为 123 T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) W(A) BEGIBN A0 123 0 1 R(A) A1 456 1 - W(A) R(A) A0 123 0 1 COMMIT A1 456 1 2 COMMIT A2 789 2 - T1-R(A) 读取 A0 版本数据 T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2 T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交） T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成 T1-R(A) 读取 A1 数据，同一事务写入的版本 T1-Commit 事务 T1 完成事务 T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2 并发控制（Concurrency Control Protocol） 参考其他并发控制的方式，MVCC 自身不能并发控制"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.102.3"><meta property="og:title" content="MVCC Concepts and HBase Implementation"><meta property="og:description" content="Multi-Version Concurrency Control 包含两个部分：
Multi-Version：存储多个版本数据，使得读写可以不冲突 Concurrency Control：并发控制，使执行过程可串行化 数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。
T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) BEGIBN W(A) A0 123 0 2 A1 456 2 - R(A) COMMIT COMMIT 初始版本为 A0，值为 123，可见范围是 0 ～ ∞ T1 的 R(A) 因为 0 < 1 < ∞，读取的值为 123 T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2 T1 的第二次 R(A) 因为 0 < 1 < 2(A0 版本的 End 是 2)，读取的值为 123 T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) W(A) BEGIBN A0 123 0 1 R(A) A1 456 1 - W(A) R(A) A0 123 0 1 COMMIT A1 456 1 2 COMMIT A2 789 2 - T1-R(A) 读取 A0 版本数据 T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2 T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交） T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成 T1-R(A) 读取 A1 数据，同一事务写入的版本 T1-Commit 事务 T1 完成事务 T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2 并发控制（Concurrency Control Protocol） 参考其他并发控制的方式，MVCC 自身不能并发控制"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/mvcc-concepts-and-hbase-impl/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-10T22:27:56+00:00"><meta property="article:modified_time" content="2022-07-10T22:27:56+00:00"><meta itemprop=name content="MVCC Concepts and HBase Implementation"><meta itemprop=description content="Multi-Version Concurrency Control 包含两个部分：
Multi-Version：存储多个版本数据，使得读写可以不冲突 Concurrency Control：并发控制，使执行过程可串行化 数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。
T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) BEGIBN W(A) A0 123 0 2 A1 456 2 - R(A) COMMIT COMMIT 初始版本为 A0，值为 123，可见范围是 0 ～ ∞ T1 的 R(A) 因为 0 < 1 < ∞，读取的值为 123 T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2 T1 的第二次 R(A) 因为 0 < 1 < 2(A0 版本的 End 是 2)，读取的值为 123 T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) W(A) BEGIBN A0 123 0 1 R(A) A1 456 1 - W(A) R(A) A0 123 0 1 COMMIT A1 456 1 2 COMMIT A2 789 2 - T1-R(A) 读取 A0 版本数据 T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2 T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交） T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成 T1-R(A) 读取 A1 数据，同一事务写入的版本 T1-Commit 事务 T1 完成事务 T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2 并发控制（Concurrency Control Protocol） 参考其他并发控制的方式，MVCC 自身不能并发控制"><meta itemprop=datePublished content="2022-07-10T22:27:56+00:00"><meta itemprop=dateModified content="2022-07-10T22:27:56+00:00"><meta itemprop=wordCount content="1038"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="MVCC Concepts and HBase Implementation"><meta name=twitter:description content="Multi-Version Concurrency Control 包含两个部分：
Multi-Version：存储多个版本数据，使得读写可以不冲突 Concurrency Control：并发控制，使执行过程可串行化 数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。
T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) BEGIBN W(A) A0 123 0 2 A1 456 2 - R(A) COMMIT COMMIT 初始版本为 A0，值为 123，可见范围是 0 ～ ∞ T1 的 R(A) 因为 0 < 1 < ∞，读取的值为 123 T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2 T1 的第二次 R(A) 因为 0 < 1 < 2(A0 版本的 End 是 2)，读取的值为 123 T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) W(A) BEGIBN A0 123 0 1 R(A) A1 456 1 - W(A) R(A) A0 123 0 1 COMMIT A1 456 1 2 COMMIT A2 789 2 - T1-R(A) 读取 A0 版本数据 T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2 T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交） T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成 T1-R(A) 读取 A1 数据，同一事务写入的版本 T1-Commit 事务 T1 完成事务 T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2 并发控制（Concurrency Control Protocol） 参考其他并发控制的方式，MVCC 自身不能并发控制"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">MVCC Concepts and HBase Implementation</h1><div class="text-sm opacity-60"><time>Jul 10, 2022</time></div></header><section><p>Multi-Version Concurrency Control 包含两个部分：</p><ol><li>Multi-Version：存储多个版本数据，使得读写可以不冲突</li><li>Concurrency Control：并发控制，使执行过程可串行化</li></ol><p>数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。</p><table><thead><tr><th>T1</th><th>T2</th><th></th><th>Version</th><th>Value</th><th>Begin</th><th>End</th></tr></thead><tbody><tr><td>BEGIBN</td><td></td><td></td><td>A0</td><td>123</td><td>0</td><td>-</td></tr><tr><td>R(A)</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>BEGIBN</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>W(A)</td><td></td><td>A0</td><td>123</td><td>0</td><td>2</td></tr><tr><td></td><td></td><td></td><td>A1</td><td>456</td><td>2</td><td>-</td></tr><tr><td>R(A)</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>COMMIT</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>COMMIT</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li>初始版本为 A0，值为 123，可见范围是 0 ～ ∞</li><li>T1 的 R(A) 因为 0 &lt; 1 &lt; ∞，读取的值为 123</li><li>T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2</li><li>T1 的第二次 R(A) 因为 0 &lt; 1 &lt; 2(A0 版本的 End 是 2)，读取的值为 123</li></ol><table><thead><tr><th>T1</th><th>T2</th><th></th><th>Version</th><th>Value</th><th>Begin</th><th>End</th></tr></thead><tbody><tr><td>BEGIBN</td><td></td><td></td><td>A0</td><td>123</td><td>0</td><td>-</td></tr><tr><td>R(A)</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>W(A)</td><td>BEGIBN</td><td></td><td>A0</td><td>123</td><td>0</td><td>1</td></tr><tr><td></td><td>R(A)</td><td></td><td>A1</td><td>456</td><td>1</td><td>-</td></tr><tr><td></td><td>W(A)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>R(A)</td><td></td><td></td><td>A0</td><td>123</td><td>0</td><td>1</td></tr><tr><td>COMMIT</td><td></td><td></td><td>A1</td><td>456</td><td>1</td><td>2</td></tr><tr><td></td><td>COMMIT</td><td></td><td>A2</td><td>789</td><td>2</td><td>-</td></tr></tbody></table><ol><li>T1-R(A) 读取 A0 版本数据</li><li>T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2</li><li>T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交）</li><li>T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成</li><li>T1-R(A) 读取 A1 数据，同一事务写入的版本</li><li>T1-Commit 事务 T1 完成事务</li><li>T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2</li></ol><h1 id=并发控制concurrency-control-protocol>并发控制（Concurrency Control Protocol）</h1><blockquote><p>参考其他并发控制的方式，MVCC 自身不能并发控制</p></blockquote><ul><li>MV-2PL</li><li>MV-TO</li><li>MV-OCC</li></ul><h1 id=多版本存储version-storage>多版本存储（Version Storage）</h1><h2 id=append-only-storage>Append-Only Storage</h2><p>所有的版本都存储在一张表中，不同版本之前之间使用类似链表的方式链接起来。遇到更新只需要追加一个新版，同时修改版本链表。</p><table><thead><tr><th>Version</th><th>Value</th><th>Pointer</th><th>New-Pointer</th></tr></thead><tbody><tr><td>A0</td><td>111</td><td>A1</td><td></td></tr><tr><td>A1</td><td>222</td><td>-</td><td>A2</td></tr><tr><td>B1</td><td>10</td><td>-</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>A2</td><td>333</td><td>-</td><td></td></tr></tbody></table><p>添加一个 A2 版本的数据需要的步骤，使用链表串联 A0->A1->A2：</p><ol><li>找到上一个版本 A1</li><li>Copy 一份 A1 的版本到 A2 同时修改 A2 的变更字段</li><li>修改 A1 的 Pointer 指向 A2</li></ol><p>采用链表管理不同的版本，也有两种方式 <strong>oldest-to-newest</strong> 和 <strong>newest-to-oldest。</strong></p><table><thead><tr><th></th><th>Head</th><th>更新</th><th>查找</th></tr></thead><tbody><tr><td>oldest-to-newest</td><td>最旧</td><td>添加一条记录 修改次新到最新的指针</td><td>遍历存在的所有版本</td></tr><tr><td>newest-to-oldest</td><td>最新</td><td>添加一条记录 修改次新到最新的指针 修改 Head 到最新</td><td>只遍历可用版本</td></tr></tbody></table><h2 id=time-travel-storage>Time-Travel Storage</h2><p>数据存储在 main table 和 time-travel 表中，main table 存储最新版本，time-travel 存储历史版本。</p><p>Main table</p><table><thead><tr><th>Version</th><th>Value</th><th>Pointer</th></tr></thead><tbody><tr><td>A2</td><td>333</td><td>TT table-A1</td></tr></tbody></table><p>Time-travel table</p><table><thead><tr><th>Version</th><th>Value</th><th>Pointer</th></tr></thead><tbody><tr><td>A0</td><td>111</td><td>-</td></tr><tr><td>A1</td><td>222</td><td>A0</td></tr></tbody></table><ul><li>新增：在 main table 中新增一条记录</li><li>更新：<ul><li>在 main table 中找到 A1，发现 Pointer 指向 time-travel table 中的 A0</li><li>copy main table A1 到 time-travel table 中</li><li>修改 time-travel table 中 A1 的 Pointer 为 A0</li><li>修改 main table 中的 A 版本为 A2，Pointer 为 A1</li></ul></li></ul><blockquote><p>time-travel table 也有 oldest-to-newest 和 newest-to-oldest 的问题</p></blockquote><h2 id=delta-storage>Delta Storage</h2><p>前面两种方式在只修改少数字段时候，都需要 copy 一份完整的数据作为新版本，会浪费更多的存储空间和 IO。delta storage 只存储变更记录，通过变更记录回溯版本。</p><p>Main table</p><table><thead><tr><th>Version</th><th>Value</th><th>Pointer</th></tr></thead><tbody><tr><td>A3</td><td>333</td><td>dss-A2</td></tr><tr><td>B1</td><td>10</td><td></td></tr></tbody></table><p>Delta Storage Segment</p><table><thead><tr><th>Version</th><th>Delta</th><th>Pointer</th></tr></thead><tbody><tr><td>A1</td><td>$value->111</td><td>-</td></tr><tr><td>A2</td><td>$value->222</td><td>A1</td></tr></tbody></table><p>整体形式上和 time-travel table 类似，只不过这里存储的不再是一份完整的数据，而是 delta 内容。假如这时候需要版本 A1，那么只需要通过 A3-value 和 A2-delta、A1-delta 就可以获取 A1 的内容。</p><h1 id=垃圾回收garbage-collection>垃圾回收（Garbage Collection）</h1><p>一般来说，随着时间的推移总是有一些版本不可能再被看到，过多的版本对写入和读取都会造成影响，所以需要回收那些用不到的版本。</p><ul><li>活跃的事务看不到的版本</li><li>被 abortd 的事务创建的版本</li></ul><p>设计上还有两个额外的问题：</p><ul><li>如何找出过期的版本？</li><li>如何确定在回收时候是安全？</li></ul><h2 id=tuple-level>Tuple-Level</h2><p>直接遍历发现老版本</p><h3 id=background-vacuuming>Background Vacuuming</h3><p>通常是一个独立线程，适用于任何存储方式</p><table><thead><tr><th>Version</th><th>Begin</th><th>End</th></tr></thead><tbody><tr><td>A100</td><td>1</td><td>9</td></tr><tr><td>B100</td><td>1</td><td>9</td></tr><tr><td>B101</td><td>10</td><td>20</td></tr></tbody></table><p>假设有 Thread #1 和 #2，分别执行 T12 和 T25，其中 A100 和 B 100 都处于不可见的版本，所以它们可以被回收。通常这种操作需要全表扫描，可以使用 bitmap 来表示 Dirty Block，减少扫描的范围。</p><h3 id=cooperative-cleaning>Cooperative Cleaning</h3><p>如果不使用独立线程定时扫描旧版本，可以在遍历路径上发现旧版本，标记成 deleted 同时修改 Head。</p><table><thead><tr><th>Version</th><th>Begin</th><th>End</th><th></th></tr></thead><tbody><tr><td>A0</td><td>1</td><td>5</td><td>deleted</td></tr><tr><td>A1</td><td>5</td><td>10</td><td>deleted</td></tr><tr><td>A2</td><td>10</td><td>20</td><td></td></tr><tr><td>A3</td><td>20</td><td>-</td><td></td></tr></tbody></table><p>T12 执行 Get(A) 操作中需要遍历 version chain，发现路径上有两个过期版本标记成 deleted，这里 version chain 必须是 <strong>oldest-to-newest</strong> 不然永远无法发现旧版本。</p><h2 id=transaction-level>Transaction-Level</h2><p>每个事务都维护自己的读写集合，可能仍然需要通过多线程来加快删除。</p><table><thead><tr><th>Version</th><th>Begin</th><th>End</th></tr></thead><tbody><tr><td>A2</td><td>1</td><td>-</td></tr><tr><td>B6</td><td>8</td><td>-</td></tr><tr><td></td><td></td><td></td></tr><tr><td>A2</td><td>1</td><td>10</td></tr><tr><td>B6</td><td>8</td><td>10</td></tr><tr><td>A3</td><td>10</td><td>-</td></tr><tr><td>B7</td><td>10</td><td>-</td></tr></tbody></table><ol><li>事务 T Begin 10 开始事务</li><li>更新数据 A，A2 版本称为老版本被 T 记录</li><li>更新数据 B，A6 版本称为老版本被 T 记录</li><li>T Commit 后 &lt; 10 的成为老版本可以被回收</li></ol><h1 id=索引管理index-management>索引管理（Index Management）</h1><ul><li>Primary Index：指向 version chain 的 Head</li><li>Secondary Indexes：<ul><li>Physical Pointers</li><li>Logical Pointers</li></ul></li></ul><h2 id=physical-pointers>Physical Pointers</h2><p>Secondary Indexes#N -> A100 -> A99 -> A98 -> A97</p><p>二级索引可能存在很多个，一旦某一个二级索引更新了 Head 那么所有的都需要被更新</p><h2 id=logical-pointers>Logical Pointers</h2><ol><li>所有的二级索引指向主索引</li><li>在 tuple id 和 Head 之间用一个 hash table 管理对应关系<ol><li>假如二级索引更新某个 tuple，那么就修改 hash table 中 tuple id 对应的 head</li></ol></li></ol><h1 id=hbase-mvcc>HBase MVCC</h1><blockquote><p>org/apache/hadoop/hbase/regionserver/MultiVersionConcurrencyControl.java</p></blockquote><p>HBase 只能支持 region 级别的行事务，所以 MVCC 也是对于一个 region 来说，在每个 HRegion 类中都有一个 <code>private final MultiVersionConcurrencyControl mvcc;</code> 用于处理并发控制。</p><ol><li>final AtomicLong readPoint = new AtomicLong(0);</li><li>final AtomicLong writePoint = new AtomicLong(0);</li><li>private final LinkedList writeQueue = new LinkedList&lt;>();</li></ol><p>类中主要是维护 readPoint 和 writePoint 这两个变量。除了这两个变量以外还有这几个核心的方法：</p><ol><li>tryAdvanceTo(long newStartPoint, long expected)：设置 readPoint 和 writePoint</li><li>begin()：基于当前最新的 writePoint 开启一个写事务，并添加到当前的队列 writeQueue 中</li><li>complete(WriteEntry writeEntry)：<ol><li>循环同步从 writeQueue 取 First WriteEntry 判断是否完成，完成后移除</li><li>writeQueue 被取空以后，把 WriteEntry 的 WriteNumber 设置成 readPoint</li><li>判断 readPoint 是否大于等于 writeEntry，意味着 complete 返回是 true 还是 false</li></ol></li><li>waitForRead(WriteEntry e)：同步阻塞提升 readPoint 到 e.getWriteNumber() 之后</li></ol><p>正常的写流程操作都会调用 <code>doMiniBatchMutate</code> 在流程的第 5 步和第 6 步，会处理 mvcc 相关的操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doMiniBatchMutate</span><span style=color:#f92672>(</span>BatchOperation<span style=color:#f92672>&lt;?&gt;</span> batchOp<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>......</span>
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        <span style=color:#75715e>// STEP 5. Write back to memStore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// NOTE: writeEntry can be null here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        writeEntry <span style=color:#f92672>=</span> batchOp<span style=color:#f92672>.</span><span style=color:#a6e22e>writeMiniBatchOperationsToMemStore</span><span style=color:#f92672>(</span>miniBatchOp<span style=color:#f92672>,</span> writeEntry<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// STEP 6. Complete MiniBatchOperations: If required calls postBatchMutate() CP hook and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// complete mvcc for last writeEntry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        batchOp<span style=color:#f92672>.</span><span style=color:#a6e22e>completeMiniBatchOperations</span><span style=color:#f92672>(</span>miniBatchOp<span style=color:#f92672>,</span> writeEntry<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        writeEntry <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        success <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Call complete rather than completeAndWait because we probably had error if walKey != null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>writeEntry <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> mvcc<span style=color:#f92672>.</span><span style=color:#a6e22e>complete</span><span style=color:#f92672>(</span>writeEntry<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>          <span style=color:#f92672>......</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>｝</span>
</span></span></code></pre></div><p>writeMiniBatchOperationsToMemStore 方法把 writeEntry apply 到 memstore 以后，调用 completeMiniBatchOperations 提升 readpoint，如果期间发生错误，对于已经构造完成的 writeEntry 仍然需要利用它提升 region 的 readpoint。</p><p>在读取流程中会构造 RegionScannerImpl 对象，RegionScannerImpl 会在初始化时候设置 scanner 的 readpoint。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// synchronize on scannerReadPoints so that nobody calculates
</span></span></span><span style=display:flex><span><span style=color:#75715e>// getSmallestReadPoint, before scannerReadPoints is updated.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>IsolationLevel isolationLevel <span style=color:#f92672>=</span> scan<span style=color:#f92672>.</span><span style=color:#a6e22e>getIsolationLevel</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> mvccReadPoint <span style=color:#f92672>=</span> PackagePrivateFieldAccessor<span style=color:#f92672>.</span><span style=color:#a6e22e>getMvccReadPoint</span><span style=color:#f92672>(</span>scan<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>scannerReadPoints<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mvccReadPoint <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPt</span> <span style=color:#f92672>=</span> mvccReadPoint<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nonce <span style=color:#f92672>==</span> HConstants<span style=color:#f92672>.</span><span style=color:#a6e22e>NO_NONCE</span> <span style=color:#f92672>||</span> rsServices <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>||</span> rsServices<span style=color:#f92672>.</span><span style=color:#a6e22e>getNonceManager</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPt</span> <span style=color:#f92672>=</span> getReadPoint<span style=color:#f92672>(</span>isolationLevel<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPt</span> <span style=color:#f92672>=</span> rsServices<span style=color:#f92672>.</span><span style=color:#a6e22e>getNonceManager</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getMvccFromOperationContext</span><span style=color:#f92672>(</span>nonceGroup<span style=color:#f92672>,</span> nonce<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  scannerReadPoints<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPt</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>HBase 只支持 READ_COMMITTED 和 READ_UNCOMMITTED 两个隔离级别，没有指定隔离级别或者是 READ_UNCOMMITTED，这里的 readpoint 就会被设置成 Long.MAX_VALUE，表示未写入完成可以被读到。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>getReadPoint</span><span style=color:#f92672>(</span>IsolationLevel isolationLevel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isolationLevel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> isolationLevel <span style=color:#f92672>==</span> IsolationLevel<span style=color:#f92672>.</span><span style=color:#a6e22e>READ_UNCOMMITTED</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This scan can read even uncommitted transactions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> Long<span style=color:#f92672>.</span><span style=color:#a6e22e>MAX_VALUE</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> mvcc<span style=color:#f92672>.</span><span style=color:#a6e22e>getReadPoint</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>RegionScannerImpl 构造完成后，需要对 KeyValueScanner 初始化，scanner 包含 memstore、StoreFiles、snapshot，可以看出无论是那个 scanner 都需要使用 readPt 来决定可见范围。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>StoreScanner</span><span style=color:#f92672>(</span>HStore store<span style=color:#f92672>,</span> ScanInfo scanInfo<span style=color:#f92672>,</span> Scan scan<span style=color:#f92672>,</span> NavigableSet<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]&gt;</span> columns<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> readPt<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    scanners <span style=color:#f92672>=</span> selectScannersFrom<span style=color:#f92672>(</span>store<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>      store<span style=color:#f92672>.</span><span style=color:#a6e22e>getScanners</span><span style=color:#f92672>(</span>cacheBlocks<span style=color:#f92672>,</span> scanUsePread<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> matcher<span style=color:#f92672>,</span> scan<span style=color:#f92672>.</span><span style=color:#a6e22e>getStartRow</span><span style=color:#f92672>(),</span>
</span></span><span style=display:flex><span>        scan<span style=color:#f92672>.</span><span style=color:#a6e22e>includeStartRow</span><span style=color:#f92672>(),</span> scan<span style=color:#f92672>.</span><span style=color:#a6e22e>getStopRow</span><span style=color:#f92672>(),</span> scan<span style=color:#f92672>.</span><span style=color:#a6e22e>includeStopRow</span><span style=color:#f92672>(),</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPt</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>｝</span>
</span></span></code></pre></div><p>在 scan 操作时候，也就是对 KeyValueScanner 执行 next 方法，也就是调用 StoreFileScanner 的 next 方法，可以发现如果有 MVCC 信息，是需要根据 ReadPoint 跳过一些数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Cell <span style=color:#a6e22e>next</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  Cell retKey <span style=color:#f92672>=</span> cur<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// only seek if we aren&#39;t at the end. cur == null implies &#39;end&#39;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cur <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      hfs<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      setCurrentCell<span style=color:#f92672>(</span>hfs<span style=color:#f92672>.</span><span style=color:#a6e22e>getCell</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>hasMVCCInfo <span style=color:#f92672>||</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>reader</span><span style=color:#f92672>.</span><span style=color:#a6e22e>isBulkLoaded</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        skipKVsNewerThanReadpoint<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>FileNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IOException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Could not iterate &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> retKey<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>skipKVsNewerThanReadpoint 方法中，不断的对 cell 执行 next 操作，直到找一个 SequenceId 小于等于 readpoint 的 cell，cell 的 SequenceId 就是 writepoint，当 mvcc 的 complate 后就会变成 region 的 readpoint</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>skipKVsNewerThanReadpoint</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We want to ignore all key-values that are newer than our current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// readPoint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Cell startKV <span style=color:#f92672>=</span> cur<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>enforceMVCC <span style=color:#f92672>&amp;&amp;</span> cur <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>cur<span style=color:#f92672>.</span><span style=color:#a6e22e>getSequenceId</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;</span> readPt<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> hasNext <span style=color:#f92672>=</span> hfs<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    setCurrentCell<span style=color:#f92672>(</span>hfs<span style=color:#f92672>.</span><span style=color:#a6e22e>getCell</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>      hasNext <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>stopSkippingKVsIfNextRow</span> <span style=color:#f92672>&amp;&amp;</span> getComparator<span style=color:#f92672>().</span><span style=color:#a6e22e>compareRows</span><span style=color:#f92672>(</span>cur<span style=color:#f92672>,</span> startKV<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;</span> 0
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cur <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h1 id=参考>参考</h1><ul><li><a href=https://15445.courses.cs.cmu.edu/fall2021/notes/18-multiversioning.pdf>https://15445.courses.cs.cmu.edu/fall2021/notes/18-multiversioning.pdf</a></li><li><a href=https://zhuanlan.zhihu.com/p/127274032>一篇讲透如何理解数据库并发控制（纯干货）</a></li><li><a href=https://jiekun.dev/posts/mvcc/>Paper Reading：聊一聊MVCC</a></li><li><a href=https://www.modb.pro/db/394162>思辨|基于MVCC的分布式事务简介 - 墨天轮</a></li></ul></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/rocksdb-single-write/><span class=mr-1.5>←</span><span>RocksDB WAL 单写者写入优化</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/rocksdb-wal/><span>Rocksdb WAL 流程分析</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>