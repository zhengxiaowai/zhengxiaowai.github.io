<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>「译」Goroutine 泄露——被遗弃的接受者 - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="原文地址
简介
Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.102.3"><meta property="og:title" content="「译」Goroutine 泄露——被遗弃的接受者"><meta property="og:description" content="原文地址
简介
Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-12T21:54:55+00:00"><meta property="article:modified_time" content="2019-05-12T21:54:55+00:00"><meta itemprop=name content="「译」Goroutine 泄露——被遗弃的接受者"><meta itemprop=description content="原文地址
简介
Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。"><meta itemprop=datePublished content="2019-05-12T21:54:55+00:00"><meta itemprop=dateModified content="2019-05-12T21:54:55+00:00"><meta itemprop=wordCount content="583"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="「译」Goroutine 泄露——被遗弃的接受者"><meta name=twitter:description content="原文地址
简介
Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">「译」Goroutine 泄露——被遗弃的接受者</h1><div class="text-sm opacity-60"><time>May 12, 2019</time></div></header><section><p><a href=https://www.ardanlabs.com/blog/2018/12/goroutine-leaks-the-abandoned-receivers.html>原文地址</a></p><h2 id=简介>简介</h2><p>Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。</p><h2 id=被遗弃接收者的泄露>被遗弃接收者的泄露</h2><p><strong>在这个例子中，你将可以看到多个 Goroutine 被阻塞，等待永远不会被发送的值</strong></p><p>文章中的这个程序启动了多个 Goroutine 来处理文件中一批数据。每个 Goroutine 从输入 channel 接受值，然后通过输出 channel 发送新值。</p><p><strong>Listing 1</strong></p><p><a href=https://play.golang.org/p/Jtpla_UvrmN>https://play.golang.org/p/Jtpla_UvrmN</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>35</span> <span style=color:#75715e>// processRecords is given a slice of values such as lines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>36</span> <span style=color:#75715e>// from a file. The order of these values is not important
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>37</span> <span style=color:#75715e>// so the function can start multiple workers to perform some
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>38</span> <span style=color:#75715e>// processing on each record then feed the results back.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>39</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processRecords</span>(<span style=color:#a6e22e>records</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span><span style=color:#ae81ff>40</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span>     <span style=color:#75715e>// Load all of the records into the input channel. It is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>42</span>     <span style=color:#75715e>// buffered with just enough capacity to hold all of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>43</span>     <span style=color:#75715e>// records so it will not block.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>44</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span>     <span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>records</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>46</span>     <span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>total</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>47</span>     <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>record</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>records</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>48</span>         <span style=color:#a6e22e>input</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>record</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>49</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>50</span>     <span style=color:#75715e>// close(input) // What if we forget to close the channel?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>51</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>52</span>     <span style=color:#75715e>// Start a pool of workers to process input and send
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>53</span>     <span style=color:#75715e>// results to output. Base the size of the worker pool on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>54</span>     <span style=color:#75715e>// the number of logical CPUs available.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>55</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>56</span>     <span style=color:#a6e22e>output</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>total</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>57</span>     <span style=color:#a6e22e>workers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
</span></span><span style=display:flex><span><span style=color:#ae81ff>58</span>     <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workers</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>59</span>         <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>60</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>61</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>62</span>     <span style=color:#75715e>// Receive from output the expected number of times. If 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>63</span>     <span style=color:#75715e>// records went in then 10 will come out.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>64</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>65</span>     <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>total</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>66</span>         <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>output</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>67</span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[result  ]: output %s\n&#34;</span>, <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>68</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>69</span> }
</span></span><span style=display:flex><span><span style=color:#ae81ff>70</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>71</span> <span style=color:#75715e>// worker is the work the program wants to do concurrently.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>72</span> <span style=color:#75715e>// This is a blog post so all the workers do is capitalize a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>73</span> <span style=color:#75715e>// string but imagine they are doing something important.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>74</span> <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>75</span> <span style=color:#75715e>// Each goroutine can&#39;t know how many records it will get so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>76</span> <span style=color:#75715e>// it must use the range keyword to receive in a loop.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>77</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>input</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>output</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span><span style=color:#ae81ff>78</span>     <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>input</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>79</span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[worker %d]: input %s\n&#34;</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>80</span>         <span style=color:#a6e22e>output</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToUpper</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>81</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>82</span>     <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[worker %d]: shutting down\n&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>83</span> }
</span></span></code></pre></div><p>在第 39 行定义了一个名为 processRecords 的函数。该函数接收一个 string 的 slice 值。在第 46 行创建了一个名为 <code>input</code> 缓存的 channel。在 47 和 48 行循环把 slice 中的 string 值发送到 channel 中。创建的输入通道具有足够的容量来保存 slice 中的每个值，因此在 48 行中的发送都不会阻塞。这个 channel 作为一个 pipeline 分布在多个 Groutine 中。</p><p>接下来的 56 到 60 行，程序创建了一个 Goroutine 池来从 pipeline 中接收值。56 行创建了一个名为 <code>output</code> 的缓存 channel，每个 Goroutine 都会把值发送到这个 channel。57 行到 59 行用 <code>worker</code> 函数创建等同于逻辑 CPU 数量的 Goroutine，传入循环变量 i、<code>input</code> channel、<code>output</code> channel。</p><p><code>woker</code> 函数被定义在第 77 行，函数的签名定义 <code>input</code> 为 <code>&lt;- chan string</code>，意味着这是一个只读 channel；另一个参数 <code>output</code> 是 <code>chan&lt;- string</code>，意味着是只写 channel。</p><p>在这个函数的 78 行中，Goroutine 使用 <code>range</code> 循环从 <code>input</code> 中接收值，使用 <code>range</code> 从 channel 中接收值直到 channel 被关闭同时再也读不出值为止。每次循环中接收到的值赋给迭代变量 <code>v</code>，同时在 79 行打印出来。然后第 80 行，<code>worker</code> 函数将 <code>v</code> 传给 <code>strings.ToUpper</code> 函数返回一个新的 <code>string</code>。这个 worker 立即把这个 string 发送到 <code>output</code> channel 中。</p><p>回到 <code>processRecords</code> 函数中，现在已经执行到第 65 行。正在运行着一个循环，直到从 <code>output</code> channel 接收并处理了所有值。在 66 行 <code>processRecords</code> 函数等待接收来自另一个 Goroutine 的值，接收到的值在 67 行打印出来。当该程序接收到每个 input 值，他会退出循环并终止改功能。</p><p>运行这个程序打印转换后的数据，看起来视乎很正常的工作，其实正在泄露多个 Goroutine，实际上程序永远不会到达 82 行，这行打印这个 worker 已经。及时 <code>processRecords</code> 函数已经返回，每个 worker 的 Goroutine 仍然在 78 行等待 input 中的值。实际上 channel 的接收者一直等待到 channel 关闭并且 channel 为空。这个问题就在于程序从来没有去关闭 channel。</p><h2 id=fix通知完成>FIX：通知完成</h2><p>修复这个泄露只需要一行代码 <code>close(input)</code>。关闭 channel 是表示 “不在发送数据” 的一种方式。关闭 channel 最合适的地方应该是在第 50 行发送完最后一个值之后，如 Listing 2 所示：</p><p><strong>Listing 2</strong></p><p><a href=https://play.golang.org/p/QNsxbT0eIay>https://play.golang.org/p/QNsxbT0eIay</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>45</span>     <span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>records</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>46</span>     <span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>total</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>47</span>     <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>record</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>records</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>48</span>         <span style=color:#a6e22e>input</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>record</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>49</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>50</span>     close(<span style=color:#a6e22e>input</span>)
</span></span></code></pre></div><p>关闭一个缓冲 channel 后，channal 中的值仍然是有效的，channel 被仅仅是关闭发送而不是接收。worker Goroutine 运行 <code>range input</code> 将会得到缓冲 channel 已经被关闭的信号，这可以让 worker 在程序退出前终止循环退出。</p><h2 id=结论>结论</h2><p>正如前一篇文章中所提到的，Go 中使用 Goroutine 变得简单，但是你有责任好好的使用它们。在这篇文章中我展示了另一个使用 Goroutine 很容易犯的错误。还是有更多使用 Goroutine 并发泄露的陷阱。未来的文章我们会继续这些陷阱。和以前一样，我将继续重复这一建议 “<a href=https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop>永远不要启动一个你不知道如何停止的 Goroutine</a>”。</p><p><strong>并发是一种有用的工具，但必须谨慎使用。</strong></p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/><span class=mr-1.5>←</span><span>Python 标准库源码分析 namedtuple</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/><span>「译」Goroutine 泄露——被遗忘的发送者</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>