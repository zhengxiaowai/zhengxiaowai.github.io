<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>「译」在 Golang 中实现枚举类型 - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="原文地址
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。
这篇文章描述用于生成的 CLI，完全的原代码 可以在 Github 上找到。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.107.0"><meta property="og:title" content="「译」在 Golang 中实现枚举类型"><meta property="og:description" content="原文地址
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。
这篇文章描述用于生成的 CLI，完全的原代码 可以在 Github 上找到。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/golang-enmu/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-28T16:10:01+00:00"><meta property="article:modified_time" content="2019-04-28T16:10:01+00:00"><meta itemprop=name content="「译」在 Golang 中实现枚举类型"><meta itemprop=description content="原文地址
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。
这篇文章描述用于生成的 CLI，完全的原代码 可以在 Github 上找到。"><meta itemprop=datePublished content="2019-04-28T16:10:01+00:00"><meta itemprop=dateModified content="2019-04-28T16:10:01+00:00"><meta itemprop=wordCount content="378"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="「译」在 Golang 中实现枚举类型"><meta name=twitter:description content="原文地址
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。
这篇文章描述用于生成的 CLI，完全的原代码 可以在 Github 上找到。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">「译」在 Golang 中实现枚举类型</h1><div class="text-sm opacity-60"><time>Apr 28, 2019</time></div></header><section><p><a href=https://stein.wtf/posts/2019-04-16/enums/>原文地址</a>
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。</p><p>这篇文章描述用于生成的 CLI，<a href=https://github.com/steinfletcher/gonum>完全的原代码</a> 可以在 Github 上找到。</p><h2 id=go-中惯用法>Go 中惯用法</h2><p>Go 语言实际上没有对枚举类型提供完成的支持。定义枚举类型的其中一种方法就是把一类相关变量定义成一种类型。Iota 可以用于定义连续的递增的整数常量。我们可以像这样定义一个 Color 类型。</p><p><a href=https://play.golang.org/p/1Zib29yiuFy>https://play.golang.org/p/1Zib29yiuFy</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Color</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Red</span> <span style=color:#a6e22e>Color</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Blue</span>             <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b1</span> <span style=color:#a6e22e>Color</span> = <span style=color:#a6e22e>Red</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b1</span> = <span style=color:#a6e22e>Red</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b1</span>) <span style=color:#75715e>// prints 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b2</span> <span style=color:#a6e22e>Color</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b2</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Blue</span>) <span style=color:#75715e>// prints true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b3</span> <span style=color:#a6e22e>Color</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b3</span> = <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b3</span>)  <span style=color:#75715e>// prints 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这种写法在 Go 代码中很常见，虽然这种方法很常用，但是有一些缺点。因为任何整数都可以给 Color 赋值，所以无法进行使用静态检查。</p><ul><li>缺乏序列化——虽然这个不经常使用(开发者想要序列化这个整数，用于传参或者记录到数据库)</li><li>缺乏可读性的值——我们需要将 const 值转化成代码中显示的值</li></ul><p>了解一种语言的习惯用法以及何时该打破这种习惯很重要。习惯用法往往会限制我们的 &ldquo;视野&rdquo;，这有时候恰恰是缺乏创造力的原因。</p><h2 id=设计枚举类型>设计枚举类型</h2><p>简洁是 Go 语言最重要的特性之一，其他语言的开发者可以很快上手。从另一方面看，可能会产生约束，比如缺乏泛型机制导致许多重复的代码。为了克服这些缺点，社区已经使用代码生成作为定义更强大和灵活类型的机制。</p><p>我们就使用这种方法来定义枚举类型，这种方法是使用生成的枚举作为 struct。我们还可以添加方法到 struct 中，struct 还支持 tag，这对于定义显示值和描述很有用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ColorEnum</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Red</span>  <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`enum:&#34;RED&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Blue</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`enum:&#34;BLUE&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我们需要做的是给每个字段生成结构的实例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Red</span>  = <span style=color:#a6e22e>Color</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;RED&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Blue</span> = <span style=color:#a6e22e>Color</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;BLUE&#34;</span>}
</span></span></code></pre></div><p>添加方法到 Color struct 支持 JSON 编码/解码，我们实现 Marshaler 的 interface 支持 JSON 的编码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>Color</span>) <span style=color:#a6e22e>MarshalJSON</span>() ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个类型序列化时候将会调用我们的自定义实现。同样我们可以实现 Unmarshaler 的 interface，这将让我们可以在代码中使用类型——这允许我们直接在 API 的数据传输对象上定义枚举。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Color</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们还可以定义一些辅助的方法来生成显示的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ColorNames returns the displays values of all enum instances as a slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ColorNames</span>() []<span style=color:#66d9ef>string</span> { <span style=color:#f92672>...</span> }
</span></span></code></pre></div><p>我们也希望从字符串生成枚举实例，所以添加还需要添加这个方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// NewColor generates a new Color from the given display value (name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewColor</span>(<span style=color:#a6e22e>value</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Color</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
</span></span></code></pre></div><p>这些行为都是可扩展的，你可以添加其他方法来返回名字，通过显示 Error() string 来支持错误，并且通过 String() string 来支持 Stringer。</p><h2 id=生成代码>生成代码</h2><h3 id=遍历抽象语法树>遍历抽象语法树</h3><p>在渲染模板之前，我们需要在源码中解析出 ColorEnum 类型。两种常用的方法是使用 <code>reflet</code> 包和 <code>ast</code> 包。我们需要扫描包级别的 struct。<code>ast</code> 包具有生成抽象语法树的能力——一种可表示 Go 源码的可遍历数据结构。我们可以遍历语法树并且匹配提供的类型，然后可以解析类型和定义的 struct tag，并用在构建模型已生成模板。我们先加载一个 go 包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cfg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>packages</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Mode</span>:  <span style=color:#a6e22e>packages</span>.<span style=color:#a6e22e>LoadSyntax</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Tests</span>: <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>pkgs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>packages</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#a6e22e>cfg</span>, <span style=color:#a6e22e>patterns</span><span style=color:#f92672>...</span>)
</span></span></code></pre></div><p><code>pkgs</code> 变量中包含每个文件的语法树。使用 <code>ast.Inspect</code> 方法来遍历 AST。它需要为每个遇到的节点调用一个函数，我们以此遍历每个文件并且处理该文件的语法树。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>files</span> {
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>Inspect</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>file</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>Node</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...handle node, check if it&#39;s something we are interested in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用者应该定义这个函数，然后按照感兴趣的 token 类型进行过滤。你可以通过节点上的此检查来过滤。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Tok</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>token</span>.<span style=color:#a6e22e>STRUCT</span> { <span style=color:#f92672>...</span> }
</span></span></code></pre></div><p>在我们的例子中，通过定义了 &ldquo;enmu:&rdquo; 标签的 struct 进行过滤。我们只是处理了源码中每个标记，并根据遇到的数据类型进行模型（自定义 Go struct）的构建。</p><h3 id=生成源代码>生成源代码</h3><p>有许多生成代码的方法。<code>Stringer</code> 工具使用 <code>fmt</code> 包标准输出。虽然这很容易实现，但是随着代码的生成的扩张，这将会变得难以操作和调试。更合理的方式是使用 <code>text/template</code> 包，并且使用 Go 强大的模板库。它允许从模板中分离生成模型的逻辑，从而可以关注点分离和让代码易于推理。生成的类型定义可能如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// {{.NewType}} is the enum that instances should be created from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> {{.<span style=color:#a6e22e>NewType</span>}} <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>  <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Enum instances
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{{<span style=color:#f92672>-</span> <span style=color:#66d9ef>range</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> .<span style=color:#a6e22e>Fields</span>}}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> {{.<span style=color:#a6e22e>Value</span>}} = {{<span style=color:#960050;background-color:#1e0010>$</span>.<span style=color:#a6e22e>NewType</span>}}{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;{{.Key}}&#34;</span>}
</span></span><span style=display:flex><span>{{<span style=color:#f92672>-</span> <span style=color:#a6e22e>end</span>}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#a6e22e>code</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>generate</span> <span style=color:#a6e22e>methods</span>
</span></span></code></pre></div><p>然后我们可以使从模型中渲染出源码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>tmpl</span>).<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>tmpl</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;instance template parse error: &#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Execute</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>model</span>)
</span></span></code></pre></div><p>当我们在制作模板时候不要担心格式化的问题。<code>format</code> 包中有一个方法，它将源码作为参数并且返回格式化的 Go 代码，所以应该应该 Go 帮你处理这个问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Source</span>(<span style=color:#a6e22e>src</span> []<span style=color:#66d9ef>byte</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
</span></span></code></pre></div><h2 id=总结>总结</h2><p>在这篇中文，我们研究了一种通过解析 Go 源码来生成枚举类型的方法。此方法可以作为模板来构建所需要的源码和作为其他代码的生成器。我们使用 Go 的 <code>text/template</code> 库可以维护的方式呈现源码。</p><p>可以在 Github 阅读 <a href=https://github.com/steinfletcher/gonum>完整的代码</a>。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/><span class=mr-1.5>←</span><span>「译」Goroutine 泄露——被遗忘的发送者</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/database-with-fk/><span>数据库到底要不要外键</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>