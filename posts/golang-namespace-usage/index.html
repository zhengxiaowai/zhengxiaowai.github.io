<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go 语言中 Namespace 用法 - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.107.0"><meta property="og:title" content="Go 语言中 Namespace 用法"><meta property="og:description" content="总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/golang-namespace-usage/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-07T20:33:05+00:00"><meta property="article:modified_time" content="2019-04-07T20:33:05+00:00"><meta itemprop=name content="Go 语言中 Namespace 用法"><meta itemprop=description content="总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。"><meta itemprop=datePublished content="2019-04-07T20:33:05+00:00"><meta itemprop=dateModified content="2019-04-07T20:33:05+00:00"><meta itemprop=wordCount content="232"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 语言中 Namespace 用法"><meta name=twitter:description content="总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">Go 语言中 Namespace 用法</h1><div class="text-sm opacity-60"><time>Apr 7, 2019</time></div></header><section><p>总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。</p><h2 id=namespace-overview>Namespace Overview</h2><p>在 Linux Kernel 中有一组名为 Namespace 的系统调用 API。主要作用是封装了全局的系统资源的调用分配，在一个进程中隔离了其他进程的可见性，让自己 “拥有” 整个计算机的资源的能力。一个典型的用途就是容器的实现。</p><p>namespace 一种只有 4 个 API：</p><ul><li>clone：创建一个隔离的进程，可以通过参数控制所拥有的资源</li><li>setns：允许一个进程到现有的 namespace</li><li>unshare：从现有 namespace 中移除一个进程</li><li>ioctl：用法发现 namespace 信息</li></ul><p>接下来主要讨论如何创建一个具有隔离性的进程，也就是 clone 这个系统调用的用法。</p><p>clone 创建一个新的 namespace（进程），可以对其控制几个方面的资源（通过 CLONE_NEW* 这系列参数）。</p><ul><li>IPC：CLONE_NEWIPC，System V IPC 和 POSIX message queue</li><li>Network：CLONE_NEWNET，网络设备等</li><li>Mount：CLONE_NEWNS，挂载点</li><li>PID：CLONE_NEWPID，进程的 ID</li><li>User：CLONE_NEWUSER：用户或组的 ID</li><li>UTS：CLONE_NEWUTS：Hostname 和 NIS domain</li></ul><p>这里 CLONE_NEWNS 比较奇特，这是最早的一个参数，后面也想不到还有更多粒度的资源控制，所以这是一个历史遗留问题。</p><h2 id=namespace-usage>Namespace Usage</h2><p>由于 Namespace 是 Linux 的系统调用，所以在其他操作系统是无法编译通过的。可以在 build 时候通过设置 <code>GOOS = linux</code> 解决，但是运行还是要放在 Linux 上运行。</p><p>在 Golang 中创建一个新的进程，通过 CLONE_NEW* flag 设置资源隔离。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// +build linux
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os/exec&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;syscall&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>exec</span>.<span style=color:#a6e22e>Command</span>(<span style=color:#e6db74>&#34;sh&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>SysProcAttr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SysProcAttr</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Cloneflags</span>: <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWUTS</span> | 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWIPC</span> | 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWPID</span> | 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWNS</span> | 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWUSER</span> | 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>CLONE_NEWNET</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Stdin</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdin</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Stdout</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Stderr</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stderr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Run</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>env GOOS=linux go build -o nsprocess</code> 编译后，copy <code>nsprocess</code> 到 linux 机器上执行。</p><p>先看一下 CLONE_NEWUSER 的功能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ id
</span></span><span style=display:flex><span>uid<span style=color:#f92672>=</span>65534<span style=color:#f92672>(</span>nobody<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>65534<span style=color:#f92672>(</span>nogroup<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>65534<span style=color:#f92672>(</span>nogroup<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>我们可以看到，这时候 UID 和我们宿主机上的不同，表明 user 资源被隔离了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ifconfig
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><p>网络设备信息也是空的，CLONE_NEWNET 的隔离也生效了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># hostname -b zxytest</span>
</span></span><span style=display:flex><span><span style=color:#75715e># hostname</span>
</span></span><span style=display:flex><span>zxytest
</span></span></code></pre></div><p>修改 hostname 后到宿主机发现 hostname 并没有被修改，这就是 CLONE_NEWUTS 的隔离性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># mount -t proc proc /proc</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ps -ef</span>
</span></span><span style=display:flex><span>UID        PID  PPID  C STIME TTY          TIME CMD
</span></span><span style=display:flex><span>root         <span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>0</span> 12:16 pts/0    00:00:00 sh
</span></span><span style=display:flex><span>root         <span style=color:#ae81ff>3</span>     <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 12:17 pts/0    00:00:00 ps -ef
</span></span></code></pre></div><p>mount proc 之后发现进程信息都没有了，只有当前的进程信息。</p><blockquote><p>ps 命名是通过读取 /proc 文件输出的，所以要先 mount proc</p></blockquote><p>以上就 Linux Namespace 的基本用法，也是 docker 的基础技术。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/golang-beachmark-details/><span class=mr-1.5>←</span><span>「译」更详细的 Go 性能测试</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/http-propagation-context/><span>「译」Go Context 在 HTTP 传播</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>