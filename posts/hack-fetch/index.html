<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#faf6f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>「震惊」你可能需要一个假的 Fetch API - 正小歪 BLOG</title><meta name=theme-color><meta name=description content="Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。
Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。
首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。"><meta name=author content><link rel="preload stylesheet" as=style href=http://hexiangyu.me/main.min.css><script defer src=http://hexiangyu.me/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://hexiangyu.me/theme.png><link rel=icon href=http://hexiangyu.me/favicon.ico><link rel=apple-touch-icon href=http://hexiangyu.me/apple-touch-icon.png><meta name=generator content="Hugo 0.107.0"><meta property="og:title" content="「震惊」你可能需要一个假的 Fetch API"><meta property="og:description" content="Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。
Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。
首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。"><meta property="og:type" content="article"><meta property="og:url" content="http://hexiangyu.me/posts/hack-fetch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-29T16:22:57+00:00"><meta property="article:modified_time" content="2017-03-29T16:22:57+00:00"><meta itemprop=name content="「震惊」你可能需要一个假的 Fetch API"><meta itemprop=description content="Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。
Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。
首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。"><meta itemprop=datePublished content="2017-03-29T16:22:57+00:00"><meta itemprop=dateModified content="2017-03-29T16:22:57+00:00"><meta itemprop=wordCount content="448"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="「震惊」你可能需要一个假的 Fetch API"><meta name=twitter:description content="Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。
Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。
首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=http://hexiangyu.me/>正小歪 BLOG</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#faf6f1"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark");setDark(darkVal?darkVal==="true":darkScheme.matches),darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">「震惊」你可能需要一个假的 Fetch API</h1><div class="text-sm opacity-60"><time>Mar 29, 2017</time></div></header><section><p>Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。</p><p>Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。</p><p>首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。</p><h2 id=简单回顾一下-promisea-规范>简单回顾一下 Promise/A+ 规范</h2><p>Promise 中文翻译「承若」，在异步世界里真的没有什么比承若更加重要了，因为真的不知道下一个出现的会是谁。</p><p>Promise 中值分成现在值和将来值两个部分，将来值正是我们所关心的，所以给 Promise 下一个简单定义就是：获取意料当中值。</p><p>在 Promise 中分成三个状态：</p><ul><li><em>pending</em>：初始状态，未被 fulfilled 或者未被 rejected。</li><li><em>fulfilled</em>：处理成功</li><li><em>rejected</em>：处理失败</li></ul><p>是的就是只有三种状态（坑点就在这里）</p><p>只提供了最简单的 API：</p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all><code>Promise.all(iterable)</code></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race><code>Promise.race(iterable)</code></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject><code>Promise.reject(reason)</code></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve><code>Promise.resolve(value)</code></a></li></ul><p>在 Promise 原型链上有两种方法：</p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch><code>Promise.prototype.catch(onRejected)</code></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then><code>Promise.prototype.then(onFulfilled, onRejected)</code></a></li></ul><p>所以 Promise 总的来说只有三种状态，四个方法、两个原型方法，多么简单。</p><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-26-promise-process.png alt></p><blockquote><p>以上内容来自 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise>MDN Promise</a></p></blockquote><h2 id=没有-timeout-机制的-fetch>没有 Timeout 机制的 Fetch</h2><p>没有这个功能确实很蛋疼，当遇到网络不顺畅的时候，不能老是等待吧，这样太恶心了。</p><p>这个槽点还是在 Promise 本身上，由于只有三种状态，成功、挂起、失败，并没有取消啊，WTF？？？黑人问号？？</p><p>怎么办？弹药不够敌人来造，最大的敌人就是 Promise 本身。Promise 中有一个方法叫做 race，该方法一组 Promise 中只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p><p>So~，有了这种机制就可以造一个假的 Timeout 出来了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hackFetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>timeout</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>params</span><span style=color:#f92672>=</span>{}) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 用 Promise 包装一个 timeout 的 reject
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_abort</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>reject</span>(<span style=color:#e6db74>&#39;abort promise&#39;</span>), <span style=color:#a6e22e>timeout</span>);
</span></span><span style=display:flex><span>  })            
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_fetch</span> <span style=color:#f92672>=</span>  <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>race</span>([<span style=color:#a6e22e>_fetch</span>, <span style=color:#a6e22e>_abort</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实现的代码很简单，两个 Promise，一个是 timeout 、一个是 Fetch，对这样就完成了。</p><p>然后再来一个工厂方法，多创建几个，来尝试一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// hackFetch 的工厂方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createHackFetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>timeout</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>params</span><span style=color:#f92672>=</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hackFetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>timeout</span>, <span style=color:#a6e22e>params</span>)
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>())
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>json</span> =&gt; <span style=color:#a6e22e>textDOM</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>              .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#39;fetch 超时&#39;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>实验使用的是 Express，实现了 4 个接口，分别 0，5，10，15 秒返回数据。</p><p>完整例子可以转到该项目的 <a href=https://github.com/zhengxiaowai/hack-fetch>Repo</a></p></blockquote><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-28-143345.jpg alt></p><p>当我点击「测试15秒 timeout 的 fetch」过后的 10 秒，出现了 alert，中断了这次 hackPromise，没有在下面的 textarea 中添加获取到字符串。</p><p>事情并不会那么美好，确认完成这个 alert 以后。观察那个 <code>fifteen-delay</code> 的请求，它依然返回数据。</p><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-28-143623.jpg alt></p><p>此坑开始在于 Promise 本身没有 cancel 机制。通过 hack 出来的带有 Timeout 机制的 Fetch，只不过的骗过了自己，但是没有骗过了浏览器。</p><p>这种方法是很危险的行为。轻的来看结果是显示和实际情况不一致罢了，但是严重的来看，本不应该出现东西却出现了，确确实实是一个漏洞。</p><p>此法有解吗？目前来看前端无解，后端可以通过设置连接的 Timeout 时间来解决这个问题，Nginx 可以通过设置 <code>send_timeout</code> 来规定 Timeout 时间。</p><h2 id=接口返回错误码不抛异常的-fetch>接口返回错误码，不抛异常的 Fetch</h2><p>在 MDN 的 <a href>Using Fetch</a> 中有那么一段话：</p><blockquote><p>The Promise returned from <code>fetch()</code> <strong>won’t reject on HTTP error status</strong> even if the response is an HTTP 404 or 500. Instead, it will resolve normally (with <code>ok</code> status set to false), and it will only reject on network failure or if anything prevented the request from completing.</p></blockquote><p>翻译过来就是：</p><p>从 <code>fetch()</code> 返回的 Promise <strong>将不会拒绝HTTP错误状态</strong>, 即使响应是一个 HTTP 404 或 500。相反，它会正常解决 (其中ok状态设置为false), 只有在网络故障时或者请求被阻止时，它才会拒绝。</p><p>这个其实这个相比上一个来说并不是什么严重的坑，只不过在开发上变的更加繁琐一些，这个恰恰又和 Fetch 的理念相悖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#39;/api/error-five-delay&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>type</span>(<span style=color:#e6db74>&#39;json&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>status</span>(<span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setTimeout</span>(() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;there is a error response&#39;</span>
</span></span><span style=display:flex><span>        }));
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>添加一个 5 秒后返回 500 错误的接口，使用一个创建正常 Fetch 的工厂方法，绑定到 button 上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createFetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span><span style=color:#f92672>=</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span>)
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>())
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>json</span> =&gt; <span style=color:#a6e22e>textDOM</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>              .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#39;请求失败&#39;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 绑定事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;error-five-fetch&#39;</span>).<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFetch</span>(<span style=color:#e6db74>&#39;/api/error-five-delay&#39;</span>);
</span></span></code></pre></div><p>5 秒之后，message 信息如愿的被添加到了 textarea 上。此时浏览器做到了它职责在控制台中给出了错误，但是 Promise 忽略了它。</p><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-28-151745.jpg alt></p><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-28-151757.jpg alt></p><p>所以如 MDN 中所言，我们必须手动的检查 response 中 ok 属性是否为 <code>false</code> ，好了要在造一个假的 Fetch 了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>xfetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span>)
</span></span><span style=display:flex><span>    		<span style=color:#75715e>// 处理错误时候的 json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>().<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>json</span> =&gt; <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>ok</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>json</span> <span style=color:#f92672>:</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>json</span>)))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>json</span> =&gt; <span style=color:#a6e22e>textDOM</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>            .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createXfetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span><span style=color:#f92672>=</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> () =&gt; <span style=color:#a6e22e>xfetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>params</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;error-handling-five-fetch&#39;</span>).<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createXfetch</span>(<span style=color:#e6db74>&#39;/api/error-five-delay&#39;</span>);
</span></span></code></pre></div><p>网络上有很多这样处理发生错误时候的 json，各种各样的方法都有，其中一样的就是必须先把 json 从 Promise 从解析出来，然后再来处理 response.ok 的状态。</p><p><img src=https://static.zhengxiaowai.cc/ipic/2017-03-28-155548.jpg alt></p><blockquote><p>完整例子可以转到该项目的 <a href=https://github.com/zhengxiaowai/hack-fetch>Repo</a></p></blockquote><p>其实这么做面对 json 数据时候没有压力，但是对于需要解析多种数据时候还需要更多的参数和封装，比如数据来源是 xml 或者 plain。</p><p>好嘛，又违背了 Promise 的设计原则。</p><h2 id=总结一下>总结一下</h2><p>文中没有实现一个 timeout 和 错误 json 处理例子，其实把 timeout 版中替换成 xfetch 就好了。</p><p>自从 Promise 的出现，在编写异步任务上有了很大的改进，Fetch 也孕育而生，在使用 Fetch 带来的简单、高效的同时也要主要它的坑点所在。本文只是总结了很小的一部分，在 Promise 还有无数的坑等着别去跳。</p><p>async / await 肯定是下一个方向，在还没完善之前，为了新老语法过渡使用 Promise 无疑是非常聪明的选择。可以给老代码以接口的方式打上一个 polyfill，同时新语法兼容 Promise 。这样完美的避开了像 Python 青黄不接的尴尬局面，Python 要加油了。</p><p>我是一个 Python 工程师，Python 大发好啊，Python 大发好啊，Python 大发好啊。</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=http://hexiangyu.me/posts/bottle-source-analysis/><span class=mr-1.5>←</span><span>Bottle 源码分析</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=http://hexiangyu.me/posts/what-every-python-project-should-have/><span>「译」Python 项目应该都有什么？</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=http://hexiangyu.me/>正小歪 BLOG</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>