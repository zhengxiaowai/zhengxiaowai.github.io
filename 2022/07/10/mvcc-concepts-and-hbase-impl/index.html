<html>
    <!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">

	

	<title>MVCC Concepts and HBase Implementation | 正小歪的博客</title>
	<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
	<link rel="shortcut icon" href="/favicon.ico">	
	<link rel="stylesheet" href="/css/bootstrap.min.css">
	<link rel="stylesheet" href="/css/style.css">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

    <body>
        <div class="root">
            <div class='topnavs container fixed-690'>
    <nav class="navbar navbar-expand-lg navbar-light">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
            aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                
                    <li class="nav-item">
                        <a class="nav-link" href="/">
                            首页
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="/categories">
                            分类
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="/archives">
                            归档
                        </a>
                    </li>
                    
            </ul>
        </div>
    </nav>
</div>
                <section class="container mainbody fixed-690">
                    <div class="post">
    <div class="post-title">
        <h1>
            MVCC Concepts and HBase Implementation 
        </h1>

        
        <div class="post-title-views">
            <span id="busuanzi_container_page_pv">
                本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次
            </span>
        </div>
        
    </div>
    <div class="post-content markdown">
        <p>Multi-Version Concurrency Control 包含两个部分：</p>
<ol>
<li>Multi-Version：存储多个版本数据，使得读写可以不冲突</li>
<li>Concurrency Control：并发控制，使执行过程可串行化</li>
</ol>
<p>数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。</p>
<table>
<thead>
<tr>
<th>T1</th>
<th>T2</th>
<th></th>
<th>Version</th>
<th>Value</th>
<th>Begin</th>
<th>End</th>
</tr>
</thead>
<tbody>
<tr>
<td>BEGIBN</td>
<td></td>
<td></td>
<td>A0</td>
<td>123</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>R(A)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BEGIBN</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>W(A)</td>
<td></td>
<td>A0</td>
<td>123</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>A1</td>
<td>456</td>
<td>2</td>
<td>-</td>
</tr>
<tr>
<td>R(A)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COMMIT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>COMMIT</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>初始版本为 A0，值为 123，可见范围是 0 ～ ∞</li>
<li>T1 的 R(A) 因为 0 &lt; 1 &lt; ∞，读取的值为 123</li>
<li>T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2</li>
<li>T1 的第二次 R(A) 因为 0 &lt; 1 &lt; 2(A0 版本的 End 是 2)，读取的值为 123</li>
</ol>
<table>
<thead>
<tr>
<th>T1</th>
<th>T2</th>
<th></th>
<th>Version</th>
<th>Value</th>
<th>Begin</th>
<th>End</th>
</tr>
</thead>
<tbody>
<tr>
<td>BEGIBN</td>
<td></td>
<td></td>
<td>A0</td>
<td>123</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>R(A)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W(A)</td>
<td>BEGIBN</td>
<td></td>
<td>A0</td>
<td>123</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>R(A)</td>
<td></td>
<td>A1</td>
<td>456</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>W(A)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>R(A)</td>
<td></td>
<td></td>
<td>A0</td>
<td>123</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>COMMIT</td>
<td></td>
<td></td>
<td>A1</td>
<td>456</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>COMMIT</td>
<td></td>
<td>A2</td>
<td>789</td>
<td>2</td>
<td>-</td>
</tr>
</tbody>
</table>
<ol>
<li>T1-R(A) 读取 A0 版本数据</li>
<li>T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2</li>
<li>T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交）</li>
<li>T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成</li>
<li>T1-R(A) 读取 A1 数据，同一事务写入的版本</li>
<li>T1-Commit 事务 T1 完成事务</li>
<li>T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2</li>
</ol>
<h1 id="并发控制（Concurrency-Control-Protocol）"><a href="#并发控制（Concurrency-Control-Protocol）" class="headerlink" title="并发控制（Concurrency Control Protocol）"></a>并发控制（Concurrency Control Protocol）</h1><blockquote>
<p>参考其他并发控制的方式，MVCC 自身不能并发控制</p>
</blockquote>
<ul>
<li>MV-2PL</li>
<li>MV-TO</li>
<li>MV-OCC</li>
</ul>
<h1 id="多版本存储（Version-Storage）"><a href="#多版本存储（Version-Storage）" class="headerlink" title="多版本存储（Version Storage）"></a>多版本存储（Version Storage）</h1><h2 id="Append-Only-Storage"><a href="#Append-Only-Storage" class="headerlink" title="Append-Only Storage"></a>Append-Only Storage</h2><p>所有的版本都存储在一张表中，不同版本之前之间使用类似链表的方式链接起来。遇到更新只需要追加一个新版，同时修改版本链表。</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Value</th>
<th>Pointer</th>
<th>New-Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>A0</td>
<td>111</td>
<td>A1</td>
<td></td>
</tr>
<tr>
<td>A1</td>
<td>222</td>
<td>-</td>
<td>A2</td>
</tr>
<tr>
<td>B1</td>
<td>10</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A2</td>
<td>333</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>添加一个 A2 版本的数据需要的步骤，使用链表串联 A0-&gt;A1-&gt;A2：</p>
<ol>
<li>找到上一个版本 A1</li>
<li>Copy 一份 A1 的版本到 A2 同时修改 A2 的变更字段</li>
<li>修改 A1 的 Pointer 指向 A2</li>
</ol>
<p>采用链表管理不同的版本，也有两种方式 <strong>oldest-to-newest</strong>  和 <strong>newest-to-oldest。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Head</th>
<th>更新</th>
<th>查找</th>
</tr>
</thead>
<tbody>
<tr>
<td>oldest-to-newest</td>
<td>最旧</td>
<td>添加一条记录 修改次新到最新的指针</td>
<td>遍历存在的所有版本</td>
</tr>
<tr>
<td>newest-to-oldest</td>
<td>最新</td>
<td>添加一条记录 修改次新到最新的指针 修改 Head 到最新</td>
<td>只遍历可用版本</td>
</tr>
</tbody>
</table>
<h2 id="Time-Travel-Storage"><a href="#Time-Travel-Storage" class="headerlink" title="Time-Travel Storage"></a>Time-Travel Storage</h2><p>数据存储在 main table 和 time-travel 表中，main table 存储最新版本，time-travel 存储历史版本。</p>
<p>Main table</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Value</th>
<th>Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>A2</td>
<td>333</td>
<td>TT table-A1</td>
</tr>
</tbody>
</table>
<p>Time-travel table</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Value</th>
<th>Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>A0</td>
<td>111</td>
<td>-</td>
</tr>
<tr>
<td>A1</td>
<td>222</td>
<td>A0</td>
</tr>
</tbody>
</table>
<ul>
<li>新增：在 main table 中新增一条记录</li>
<li>更新：<ul>
<li>在 main table 中找到 A1，发现 Pointer 指向 time-travel table 中的 A0</li>
<li>copy main table A1 到 time-travel table 中</li>
<li>修改 time-travel table 中 A1 的 Pointer 为 A0</li>
<li>修改 main table 中的 A 版本为 A2，Pointer 为 A1</li>
</ul>
</li>
</ul>
<blockquote>
<p> time-travel table 也有 oldest-to-newest 和 newest-to-oldest 的问题</p>
</blockquote>
<h2 id="Delta-Storage"><a href="#Delta-Storage" class="headerlink" title="Delta Storage"></a>Delta Storage</h2><p>前面两种方式在只修改少数字段时候，都需要 copy 一份完整的数据作为新版本，会浪费更多的存储空间和 IO。delta storage 只存储变更记录，通过变更记录回溯版本。</p>
<p>Main table</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Value</th>
<th>Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>A3</td>
<td>333</td>
<td>dss-A2</td>
</tr>
<tr>
<td>B1</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Delta Storage Segment</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Delta</th>
<th>Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>$value-&gt;111</td>
<td>-</td>
</tr>
<tr>
<td>A2</td>
<td>$value-&gt;222</td>
<td>A1</td>
</tr>
</tbody>
</table>
<p>整体形式上和 time-travel table 类似，只不过这里存储的不再是一份完整的数据，而是 delta 内容。假如这时候需要版本 A1，那么只需要通过 A3-value 和 A2-delta、A1-delta 就可以获取 A1 的内容。</p>
<h1 id="垃圾回收（Garbage-Collection）"><a href="#垃圾回收（Garbage-Collection）" class="headerlink" title="垃圾回收（Garbage Collection）"></a>垃圾回收（Garbage Collection）</h1><p>一般来说，随着时间的推移总是有一些版本不可能再被看到，过多的版本对写入和读取都会造成影响，所以需要回收那些用不到的版本。</p>
<ul>
<li>活跃的事务看不到的版本</li>
<li>被 abortd 的事务创建的版本</li>
</ul>
<p>设计上还有两个额外的问题：</p>
<ul>
<li>如何找出过期的版本？</li>
<li>如何确定在回收时候是安全？</li>
</ul>
<h2 id="Tuple-Level"><a href="#Tuple-Level" class="headerlink" title="Tuple-Level"></a>Tuple-Level</h2><p>直接遍历发现老版本</p>
<h3 id="Background-Vacuuming"><a href="#Background-Vacuuming" class="headerlink" title="Background Vacuuming"></a>Background Vacuuming</h3><p>通常是一个独立线程，适用于任何存储方式</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Begin</th>
<th>End</th>
</tr>
</thead>
<tbody>
<tr>
<td>A100</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>B100</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>B101</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>假设有 Thread #1 和 #2，分别执行 T12 和 T25，其中 A100 和 B 100 都处于不可见的版本，所以它们可以被回收。通常这种操作需要全表扫描，可以使用 bitmap 来表示 Dirty Block，减少扫描的范围。</p>
<h3 id="Cooperative-Cleaning"><a href="#Cooperative-Cleaning" class="headerlink" title="Cooperative Cleaning"></a>Cooperative Cleaning</h3><p>如果不使用独立线程定时扫描旧版本，可以在遍历路径上发现旧版本，标记成 deleted 同时修改 Head。</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Begin</th>
<th>End</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A0</td>
<td>1</td>
<td>5</td>
<td>deleted</td>
</tr>
<tr>
<td>A1</td>
<td>5</td>
<td>10</td>
<td>deleted</td>
</tr>
<tr>
<td>A2</td>
<td>10</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>A3</td>
<td>20</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>T12 执行 Get(A) 操作中需要遍历 version chain，发现路径上有两个过期版本标记成 deleted，这里 version chain 必须是 <strong>oldest-to-newest</strong> 不然永远无法发现旧版本。</p>
<h2 id="Transaction-Level"><a href="#Transaction-Level" class="headerlink" title="Transaction-Level"></a>Transaction-Level</h2><p>每个事务都维护自己的读写集合，可能仍然需要通过多线程来加快删除。</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Begin</th>
<th>End</th>
</tr>
</thead>
<tbody>
<tr>
<td>A2</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>B6</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A2</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>B6</td>
<td>8</td>
<td>10</td>
</tr>
<tr>
<td>A3</td>
<td>10</td>
<td>-</td>
</tr>
<tr>
<td>B7</td>
<td>10</td>
<td>-</td>
</tr>
</tbody>
</table>
<ol>
<li>事务 T Begin 10 开始事务</li>
<li>更新数据 A，A2 版本称为老版本被 T 记录</li>
<li>更新数据 B，A6 版本称为老版本被 T 记录</li>
<li>T Commit 后 &lt; 10 的成为老版本可以被回收</li>
</ol>
<h1 id="索引管理（Index-Management）"><a href="#索引管理（Index-Management）" class="headerlink" title="索引管理（Index Management）"></a>索引管理（Index Management）</h1><ul>
<li>Primary Index：指向 version chain 的 Head</li>
<li>Secondary Indexes：<ul>
<li>Physical Pointers</li>
<li>Logical Pointers</li>
</ul>
</li>
</ul>
<h2 id="Physical-Pointers"><a href="#Physical-Pointers" class="headerlink" title="Physical Pointers"></a>Physical Pointers</h2><p>Secondary Indexes#N -&gt; A100 -&gt; A99 -&gt; A98 -&gt; A97</p>
<p>二级索引可能存在很多个，一旦某一个二级索引更新了 Head 那么所有的都需要被更新</p>
<h2 id="Logical-Pointers"><a href="#Logical-Pointers" class="headerlink" title="Logical Pointers"></a>Logical Pointers</h2><ol>
<li>所有的二级索引指向主索引</li>
<li>在 tuple id 和 Head 之间用一个 hash table 管理对应关系<ol>
<li>假如二级索引更新某个 tuple，那么就修改 hash table 中 tuple id 对应的 head </li>
</ol>
</li>
</ol>
<h1 id="HBase-MVCC"><a href="#HBase-MVCC" class="headerlink" title="HBase MVCC"></a>HBase MVCC</h1><blockquote>
<p>org/apache/hadoop/hbase/regionserver/MultiVersionConcurrencyControl.java</p>
</blockquote>
<p>HBase 只能支持 region 级别的行事务，所以 MVCC 也是对于一个 region 来说，在每个 HRegion 类中都有一个 <code>private final MultiVersionConcurrencyControl mvcc;</code> 用于处理并发控制。</p>
<ol>
<li>final AtomicLong readPoint = new AtomicLong(0);</li>
<li>final AtomicLong writePoint = new AtomicLong(0);</li>
<li>private final LinkedList<writeentry> writeQueue = new LinkedList&lt;&gt;();</writeentry></li>
</ol>
<p>类中主要是维护 readPoint 和 writePoint 这两个变量。除了这两个变量以外还有这几个核心的方法：</p>
<ol>
<li>tryAdvanceTo(long newStartPoint, long expected)：设置 readPoint 和 writePoint</li>
<li>begin()：基于当前最新的 writePoint 开启一个写事务，并添加到当前的队列 writeQueue 中</li>
<li>complete(WriteEntry writeEntry)：<ol>
<li>循环同步从 writeQueue 取 First WriteEntry 判断是否完成，完成后移除</li>
<li>writeQueue 被取空以后，把 WriteEntry 的 WriteNumber 设置成 readPoint</li>
<li>判断 readPoint 是否大于等于 writeEntry，意味着 complete 返回是 true 还是 false</li>
</ol>
</li>
<li>waitForRead(WriteEntry e)：同步阻塞提升 readPoint 到 e.getWriteNumber() 之后</li>
</ol>
<p>正常的写流程操作都会调用 <code>doMiniBatchMutate</code> 在流程的第 5 步和第 6 步，会处理 mvcc 相关的操作。</p>
<pre class=" language-Java"><code class="language-Java">private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {
    try {
        ......

        // STEP 5. Write back to memStore
        // NOTE: writeEntry can be null here
        writeEntry = batchOp.writeMiniBatchOperationsToMemStore(miniBatchOp, writeEntry);

        // STEP 6. Complete MiniBatchOperations: If required calls postBatchMutate() CP hook and
        // complete mvcc for last writeEntry
        batchOp.completeMiniBatchOperations(miniBatchOp, writeEntry);
        writeEntry = null;
        success = true;
    } finally {
          // Call complete rather than completeAndWait because we probably had error if walKey != null
          if (writeEntry != null) mvcc.complete(writeEntry);

          ......
    }
｝
</code></pre>
<p>writeMiniBatchOperationsToMemStore 方法把 writeEntry apply 到 memstore 以后，调用 completeMiniBatchOperations 提升 readpoint，如果期间发生错误，对于已经构造完成的 writeEntry 仍然需要利用它提升 region 的 readpoint。</p>
<p>在读取流程中会构造 RegionScannerImpl 对象，RegionScannerImpl 会在初始化时候设置 scanner 的 readpoint。</p>
<pre class=" language-Java"><code class="language-Java">// synchronize on scannerReadPoints so that nobody calculates
// getSmallestReadPoint, before scannerReadPoints is updated.
IsolationLevel isolationLevel = scan.getIsolationLevel();
long mvccReadPoint = PackagePrivateFieldAccessor.getMvccReadPoint(scan);
synchronized (scannerReadPoints) {
  if (mvccReadPoint > 0) {
    this.readPt = mvccReadPoint;
  } else if (nonce == HConstants.NO_NONCE || rsServices == null
      || rsServices.getNonceManager() == null) {
    this.readPt = getReadPoint(isolationLevel);
  } else {
    this.readPt = rsServices.getNonceManager().getMvccFromOperationContext(nonceGroup, nonce);
  }
  scannerReadPoints.put(this, this.readPt);
}
</code></pre>
<p>HBase 只支持 READ_COMMITTED 和 READ_UNCOMMITTED 两个隔离级别，没有指定隔离级别或者是 READ_UNCOMMITTED，这里的 readpoint 就会被设置成 Long.MAX_VALUE，表示未写入完成可以被读到。</p>
<pre class=" language-Java"><code class="language-Java">public long getReadPoint(IsolationLevel isolationLevel) {
  if (isolationLevel != null && isolationLevel == IsolationLevel.READ_UNCOMMITTED) {
    // This scan can read even uncommitted transactions
    return Long.MAX_VALUE;
  }
  return mvcc.getReadPoint();
}
</code></pre>
<p>RegionScannerImpl 构造完成后，需要对 KeyValueScanner 初始化，scanner 包含 memstore、StoreFiles、snapshot，可以看出无论是那个 scanner 都需要使用 readPt 来决定可见范围。</p>
<pre class=" language-Java"><code class="language-Java">public StoreScanner(HStore store, ScanInfo scanInfo, Scan scan, NavigableSet<byte[]> columns,
  long readPt) throws IOException {
    scanners = selectScannersFrom(store,
      store.getScanners(cacheBlocks, scanUsePread, false, matcher, scan.getStartRow(),
        scan.includeStartRow(), scan.getStopRow(), scan.includeStopRow(), this.readPt));
  ｝
</code></pre>
<p>在 scan 操作时候，也就是对 KeyValueScanner 执行 next 方法，也就是调用 StoreFileScanner 的 next 方法，可以发现如果有 MVCC 信息，是需要根据 ReadPoint 跳过一些数据。</p>
<pre class=" language-Java"><code class="language-Java">@Override
public Cell next() throws IOException {
  Cell retKey = cur;

  try {
    // only seek if we aren't at the end. cur == null implies 'end'.
    if (cur != null) {
      hfs.next();
      setCurrentCell(hfs.getCell());
      if (hasMVCCInfo || this.reader.isBulkLoaded()) {
        skipKVsNewerThanReadpoint();
      }
    }
  } catch (FileNotFoundException e) {
    throw e;
  } catch (IOException e) {
    throw new IOException("Could not iterate " + this, e);
  }
  return retKey;
}
</code></pre>
<p>skipKVsNewerThanReadpoint 方法中，不断的对 cell 执行 next 操作，直到找一个 SequenceId 小于等于 readpoint 的 cell，cell 的 SequenceId 就是 writepoint，当 mvcc 的 complate 后就会变成 region 的 readpoint</p>
<pre class=" language-Java"><code class="language-Java">protected boolean skipKVsNewerThanReadpoint() throws IOException {
  // We want to ignore all key-values that are newer than our current
  // readPoint
  Cell startKV = cur;
  while (enforceMVCC && cur != null && (cur.getSequenceId() > readPt)) {
    boolean hasNext = hfs.next();
    setCurrentCell(hfs.getCell());
    if (
      hasNext && this.stopSkippingKVsIfNextRow && getComparator().compareRows(cur, startKV) > 0
    ) {
      return false;
    }
  }

  if (cur == null) {
    return false;
  }

  return true;
}
</code></pre>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/18-multiversioning.pdf" target="_blank" rel="noopener">https://15445.courses.cs.cmu.edu/fall2021/notes/18-multiversioning.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/127274032" target="_blank" rel="noopener">一篇讲透如何理解数据库并发控制（纯干货）</a></li>
<li><a href="https://jiekun.dev/posts/mvcc/" target="_blank" rel="noopener">Paper Reading：聊一聊MVCC</a></li>
<li><a href="https://www.modb.pro/db/394162" target="_blank" rel="noopener">思辨|基于MVCC的分布式事务简介 - 墨天轮</a></li>
</ul>
 
    </div>
    <div class="post-foot">
        <div id="disqus_thread"></div>
    </div>
</div>


                </section>
                <footer class="container fixed-690 footer">
    <div>
        <span>Power by <a href="https://hexo.io">Hexo</a></span>
    </div>
    <div>
        <span>Theme <a href="https://github.com/zhengxiaowai/hexo-theme-lessless">lessless</a></span>
    </div>
        
            
<div>
    <span id="hexiangyutest_container_site_pv">
    PV: <span id="busuanzi_value_site_pv"></span>
    </span>
    <span id="busuanzi_container_site_uv">
    UV: <span id="busuanzi_value_site_uv"></span>
    </span>
</div>

        
        
            <div>
    <span><a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">闽ICP备17000267号-1</a></span>
</div>
        
</footer>
        </div>
        
<script src="/js/jquery-3.2.1.slim.min.js"></script>
<script src="/js/popper.min.js"></script>
<script src="/js/bootstrap.min.js"></script>


    
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://hexiangyu.me/2022/07/10/mvcc-concepts-and-hbase-impl/';
        this.page.identifier = '2022/07/10/mvcc-concepts-and-hbase-impl/';
        this.page.title = 'MVCC Concepts and HBase Implementation';
    };
    var d = document, s = d.createElement('script');
    s.src = '//hexiangyus.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
</script>


    </body>
</html>