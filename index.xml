<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>正小歪 BLOG</title><link>http://hexiangyu.me/</link><description>Recent content on 正小歪 BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 11 Nov 2022 09:15:53 +0800</lastBuildDate><atom:link href="http://hexiangyu.me/index.xml" rel="self" type="application/rss+xml"/><item><title>CMU 15-445/645 Lecture 6: Trees Indexes I</title><link>http://hexiangyu.me/posts/cmu-15-445-tree-indexes1/</link><pubDate>Fri, 11 Nov 2022 09:15:53 +0800</pubDate><guid>http://hexiangyu.me/posts/cmu-15-445-tree-indexes1/</guid><description>表索引是表属性子集中的一个副本，负责组织和排序，通过这些属性，可以更有效地访问。DBMS 需要确保表中的内容和索引在逻辑同步。
DBMS 工作之一就是要找出最佳的索引去执行每一次查询。在实际情况中，索引的数量经常需要做出取舍，如果索引数量过多会有：
存储数据过大：索引往往需要额外的存储空间
维护成本过高：更新数据时候索引也要被更新
在表索引中经常使用的数据结构是 B-Tree，B-Tree 既指的是平衡树一族的数据结构，也是它们当中的一个数据结构，B-Tree 一族包括：
B-Tree(1971)
B+Tree(1973)
B*Tree(1977)
B-Link-Tree(1981)
B+Tree 是自平衡树，总是保持数据的有序性，方便查找和顺序访问，插入和删除的时间复杂度都是 O(log n)。
二分查找树的更通用形式，node 上可以拥有两个以上的节点
为大量读取读写数据的系统进行了优化
虽然这种数据结构是为了慢速硬盘和内存设计的数据结构，但是即使放在现在有更快的硬件加持下，也是最好的选择之一。
B+Tree 是一棵多路查找树，意味着它一个叶子节点可以被多条路径找到，拥有如下性质：
完美的平衡（例如，叶子节点总是保持一样的高度）
除了根节点外，至少要保持半满状态，M/2-1 &amp;lt;= #key &amp;lt;= M-1
每个内部节点有 k 个 key，就会有 k+1 个非空子节点
在 B+ Tree 中节点分为 inner node、leaf node，leadf nodes 使用双向链表链接。inner node 结构为 &amp;lt;node*&amp;gt; | ，这里的 node 指针指向下一层的 node，如果没有可能是 null；leaf node 结构与 inner node 不同，组织形式为 | ，value 可以是具体的值也可以是某些 ID。
B+ 树 node 本质就是一个 kv 对组成的数组，value 在 inner node 和 leaf node 上有不同的表现形式，node 组成的数组经常按照有序的方式排列，方便顺序查找。</description></item><item><title>RocksDB WAL 单写者写入优化</title><link>http://hexiangyu.me/posts/rocksdb-single-write/</link><pubDate>Tue, 06 Sep 2022 08:00:44 +0800</pubDate><guid>http://hexiangyu.me/posts/rocksdb-single-write/</guid><description>背景 由于 WAL 需要有序写入，但是 RocksDB 的 DBImpl::Write 本身又是多线程并发，所以在调用 Write 时候有一个先后顺序的问题，一般的解决办法就是写入一个队列中，然后不断的从队列读取写入 WAL 中，这种方式比较低效，LevelDB 优化成把多个 Write 合并成一个 WriteBatch 写入 WAL 中，其他线程等待完成，RocksDB 使用自旋和自适应的 short-wait 进步一优化，使得 WAL 的写入效率进一步提高。
LevelDB 实现 LevelDB 对这种情况做了一个简单优化，每次只有队头是真正的处理线程，对头会把队列中的其他待写入的内容合并成一个 WriteBatch 一次性写入 WAL 中，同时非对头线程会被 pthread_cond_wait 阻塞住，等待对头线程完成。
MutexLock l(&amp;amp;mutex_); writers_.push_back(&amp;amp;w); while (!w.done &amp;amp;&amp;amp; &amp;amp;w != writers_.front()) { w.cv.Wait(); } if (w.done) { return w.status; } 完成了以后非队头只需要判断一下状态就可以返回了，这么一看确实提升了不少效率，每次 IO 对一个单点写入的来说都是比较重的操作，合并成一次写入极大解决的耗在 IO 的时间。
pthread_cond_wait 存在的问题 虽然解决了 IO 的耗时，但是非队头线程会在各自的线程中 pthread_cond_wait 等待对头完成。几乎当前主流平台的 condition variable 都有虚假唤醒 （Spurious wakeup） 的问题，同样基于 futex 实现的 pthread_cond_wait 也有这个问题。</description></item><item><title>MVCC Concepts and HBase Implementation</title><link>http://hexiangyu.me/posts/mvcc-concepts-and-hbase-impl/</link><pubDate>Sun, 10 Jul 2022 22:27:56 +0000</pubDate><guid>http://hexiangyu.me/posts/mvcc-concepts-and-hbase-impl/</guid><description>Multi-Version Concurrency Control 包含两个部分：
Multi-Version：存储多个版本数据，使得读写可以不冲突 Concurrency Control：并发控制，使执行过程可串行化 数据对象在物理上存储多个版本，但是在逻辑上表示为一个对象。当写入时候创建一个新版本的对象，当读取时候读取一个存在的最新对象。
T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) BEGIBN W(A) A0 123 0 2 A1 456 2 - R(A) COMMIT COMMIT 初始版本为 A0，值为 123，可见范围是 0 ～ ∞ T1 的 R(A) 因为 0 &amp;lt; 1 &amp;lt; ∞，读取的值为 123 T2 的 W(A) 写入新版 A1，可见范围是 2 ～ ∞，A0 可见范围变为 0 ～ 2 T1 的第二次 R(A) 因为 0 &amp;lt; 1 &amp;lt; 2(A0 版本的 End 是 2)，读取的值为 123 T1 T2 Version Value Begin End BEGIBN A0 123 0 - R(A) W(A) BEGIBN A0 123 0 1 R(A) A1 456 1 - W(A) R(A) A0 123 0 1 COMMIT A1 456 1 2 COMMIT A2 789 2 - T1-R(A) 读取 A0 版本数据 T1-W(A) 写入 A1 版本，Begin 是 1，修改 A0 版本的 End 为 2 T2-R(A) 读取 A0 版本，因为 A1 版本还没提交（读已提交） T2-W(A) 发生 WW 冲突，需要阻塞到 T1 事务完成 T1-R(A) 读取 A1 数据，同一事务写入的版本 T1-Commit 事务 T1 完成事务 T2-W(A) 创建新版本 A2 Begin 为 2，同时修改 A1 的 End 为 2 并发控制（Concurrency Control Protocol） 参考其他并发控制的方式，MVCC 自身不能并发控制</description></item><item><title>Rocksdb WAL 流程分析</title><link>http://hexiangyu.me/posts/rocksdb-wal/</link><pubDate>Sun, 12 Jun 2022 19:46:44 +0000</pubDate><guid>http://hexiangyu.me/posts/rocksdb-wal/</guid><description>WAL(Write Ahead Log) 可以将 memtable 的操作做为日志写入磁盘，在发生故障后可以通过 WAL 重建 memtable，恢复到故障前的状态。当 memtable 刷到磁盘上后，这部分 WAL 会被归档，过一段时间后删除。
LOG 格式 一个 LOG 文件由 N 个固定长度的 Block 组成，每个 Block 长度是 kBlockSize(32k)。每个 Block 中由 0 到 N 个Record 组成，如果一个 Record 不足 kBlockSize 会用 null 填充，超过一个 kBlockSize 会用 Type 表示出来。
+-----+-------------+--+----+----------+------+-- ... ----+ File | r0 | r1 |P | r2 | r3 | r4 | | +-----+-------------+--+----+----------+------+-- ... ----+ &amp;lt;--- kBlockSize ------&amp;gt;|&amp;lt;-- kBlockSize ------&amp;gt;| rn = variable size records P = Padding Record 有两种格式一种是 Legacy 另一种的 Recyclable。</description></item><item><title>C++ Primer 读书笔记</title><link>http://hexiangyu.me/posts/cpp-primer-learning/</link><pubDate>Fri, 30 Apr 2021 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/cpp-primer-learning/</guid><description>➡️ C++ Primer 读书笔记</description></item><item><title>Python 标准库源码分析 namedtuple</title><link>http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/</link><pubDate>Sun, 12 May 2019 21:58:01 +0000</pubDate><guid>http://hexiangyu.me/posts/python-stanard-libary-collections-namedtuple/</guid><description>&lt;p>&lt;code>namedtuple&lt;/code> 是一个简化 &lt;code>tuple&lt;/code> 操作的工厂函数，对于普通元组我们在访问上只能通过游标的访问，在表现力上有时候比不上对象。&lt;/p>
&lt;p>命名的元组实例没有每个实例的字典，因此它们是轻量级的，并且不需要比常规元组更多的内存。&lt;/p>
&lt;p>假如想计算两个点之间的距离根据定义：&lt;/p></description></item><item><title>「译」Goroutine 泄露——被遗弃的接受者</title><link>http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/</link><pubDate>Sun, 12 May 2019 21:54:55 +0000</pubDate><guid>http://hexiangyu.me/posts/goroutine-leaks-the-abandoned-receivers/</guid><description>&lt;p>&lt;a href="https://www.ardanlabs.com/blog/2018/12/goroutine-leaks-the-abandoned-receivers.html">原文地址&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Goroutine 泄露在 Go 编程中是很常见的问题。在我的前一篇文章中，我介绍了 Goroutine 泄露的问题，并提供一个许多开发者都会犯的错误。这篇文章继续前文，讨论另一个关于 Goroutine 泄露的场景。&lt;/p></description></item><item><title>「译」Goroutine 泄露——被遗忘的发送者</title><link>http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/</link><pubDate>Sun, 12 May 2019 21:54:37 +0000</pubDate><guid>http://hexiangyu.me/posts/goroutine-leaks-the-forgotten-sender/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发编程允许开发者使用多个执行者去解决问题，这么做通常可以提高性能。并发并不意味着多个执行者同时运行，意味着执行的顺序从有序变成无序。在过去这种编程方法（并发编程）一般是由标准库或者第三方开发者为主导。&lt;/p>
&lt;p>在 Go 中类似 Gotoutines 和 channels 的并发特性都是集成语言中同时减少乃至移除了对库的依赖，这就造成了在 Go 中写并发编程很容易的错觉。在决定使用并发的时候还是需要谨慎，如果没有正确的使用还是会带来一些特别的副作用和陷阱。如果你不小心，这些陷阱会产生复杂和令人厌恶的错误。&lt;/p></description></item><item><title>「译」在 Golang 中实现枚举类型</title><link>http://hexiangyu.me/posts/golang-enmu/</link><pubDate>Sun, 28 Apr 2019 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-enmu/</guid><description>&lt;p>&lt;a href="https://stein.wtf/posts/2019-04-16/enums/">原文地址&lt;/a>
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。&lt;/p>
&lt;p>这篇文章描述用于生成的 CLI，&lt;a href="https://github.com/steinfletcher/gonum">完全的原代码&lt;/a> 可以在 Github 上找到。&lt;/p></description></item><item><title>数据库到底要不要外键</title><link>http://hexiangyu.me/posts/database-with-fk/</link><pubDate>Sun, 28 Apr 2019 16:09:34 +0000</pubDate><guid>http://hexiangyu.me/posts/database-with-fk/</guid><description>&lt;p>数据库的本质是存储数据，在这个之上还要维护数据的完整性。在维护完整性数据库提供几种方法，一种是事务，一种是外键 FK。这两种方式是分别处理两种情况，事务处理的是多个表中记录的原子性，FK 是处理多条有关系的记录。&lt;/p></description></item><item><title>「译」Golang 使用高阶函数实现依赖注入</title><link>http://hexiangyu.me/posts/go-dependency-injection-md/</link><pubDate>Sun, 28 Apr 2019 00:13:33 +0000</pubDate><guid>http://hexiangyu.me/posts/go-dependency-injection-md/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://stein.wtf/posts/2019-03-12/inject/">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>你可以在 github.com/steinfletcher/func-dependency-injection-go 找到完整的代码。这个例子包含了一个完整的 REST 的 HTTP 服务器。&lt;/p></description></item><item><title>MySQL 排序机制</title><link>http://hexiangyu.me/posts/mysql-order-by-md/</link><pubDate>Sun, 21 Apr 2019 00:10:07 +0000</pubDate><guid>http://hexiangyu.me/posts/mysql-order-by-md/</guid><description>&lt;p>在 MySQL 中经常使用 Order by 对数据进行排序，其实排序这个行为是比较消耗 IO 的过程，有时候需要回表多次才可以完成排序，所以在任何时候都需要对排序的原理要心知肚明。&lt;/p>
&lt;p>在 MySQL 中排序按照是否使用外部存储可以分为，内存排序和外部排序两种。根据排序所需的字段可以分成 rowid 排序和全字段排序两种。&lt;/p>
&lt;p>在 MySQL 执行排序的时候会分配一块内存 sort_buffer，MySQL 把需要排序的字段放入这个 sort_buffer 中，让，后在 sort_buffer 执行排序的过程，如果 sort_buffer 大小不够，就要使用外部存储。&lt;/p></description></item><item><title>「译」在 Golang 中实现枚举类型</title><link>http://hexiangyu.me/posts/go-enums-md/</link><pubDate>Sun, 14 Apr 2019 00:03:17 +0000</pubDate><guid>http://hexiangyu.me/posts/go-enums-md/</guid><description>&lt;p>&lt;a href="https://stein.wtf/posts/2019-04-16/enums/">原文地址&lt;/a>
在这篇文章中，我们将介绍使用 go generate 和 abstract 语法树遍历生成强大的枚举类型。&lt;/p>
&lt;p>这篇文章描述用于生成的 CLI，&lt;a href="https://github.com/steinfletcher/gonum">完全的原代码&lt;/a> 可以在 Github 上找到。&lt;/p></description></item><item><title>CGroups 控制进程资源</title><link>http://hexiangyu.me/posts/linux-cgroups-md/</link><pubDate>Sun, 14 Apr 2019 00:01:08 +0000</pubDate><guid>http://hexiangyu.me/posts/linux-cgroups-md/</guid><description>&lt;p>cgroups 是 Linux 内核中的一个功能，用来限制、控制分离一个进程的资源，比如 CPU、内存、IO 等。&lt;/p></description></item><item><title>「译」更详细的 Go 性能测试</title><link>http://hexiangyu.me/posts/golang-beachmark-details/</link><pubDate>Sun, 07 Apr 2019 20:33:27 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-beachmark-details/</guid><description>&lt;p>&lt;a href="https://medium.com/@egonelbre/benchmarking-with-details-1cf3e61d459d">原文连接&lt;/a>&lt;/p>
&lt;p>我一直在优化我的 go 代码并且一直优化我的性能测试方案。&lt;/p></description></item><item><title>Go 语言中 Namespace 用法</title><link>http://hexiangyu.me/posts/golang-namespace-usage/</link><pubDate>Sun, 07 Apr 2019 20:33:05 +0000</pubDate><guid>http://hexiangyu.me/posts/golang-namespace-usage/</guid><description>&lt;p>总所周知 Docker 最早诞生于 Linux 平台，利用的是 Linux LXC 技术作为基础。Docker 作为一种 “轻量级虚拟机” 跑在通用操作系统中，那么势必就要对容器进行隔离，保证在宿主机内的独立性。&lt;/p></description></item><item><title>「译」Go Context 在 HTTP 传播</title><link>http://hexiangyu.me/posts/http-propagation-context/</link><pubDate>Sun, 31 Mar 2019 22:21:30 +0000</pubDate><guid>http://hexiangyu.me/posts/http-propagation-context/</guid><description>&lt;p>Go 1.7 引入了一个内置的 context 类型，在系统中可以使用 Context 来传递元数据，例如不同函数或者不同线程甚至进程的传递 Request ID。&lt;/p>
&lt;p>Go 将 Context 包引入标准库以统一 context 的使用。在此之前每个框架或者库都有自己的 context 。它们之间还无法兼容，导致了碎片化，最终在各处 context 的传播上就有不少的麻烦。&lt;/p></description></item><item><title>两阶段提交协议</title><link>http://hexiangyu.me/posts/2pc/</link><pubDate>Sun, 31 Mar 2019 22:20:59 +0000</pubDate><guid>http://hexiangyu.me/posts/2pc/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">两阶段提交协议&lt;/a>&lt;/p>
&lt;p>在分布式系统中每个节点都可以知道自己的操作是成功还是失败，但是无法知道其他节点的状态。为了保证一个事务的 ACID 特性，一个节点发生失败就要在所有节点上执行 rollback 操作。需要引入一个 &lt;strong>协调者&lt;/strong> 来维护各个 &lt;strong>参与者&lt;/strong> 的状态，以保证最终一致。&lt;/p></description></item><item><title>「译」把项目从 Dep 迁移到 Go Modules</title><link>http://hexiangyu.me/posts/migrating-projects-from-dep-to-go-modules/</link><pubDate>Mon, 25 Mar 2019 22:46:31 +0000</pubDate><guid>http://hexiangyu.me/posts/migrating-projects-from-dep-to-go-modules/</guid><description>&lt;p>&lt;a href="http://elliot.land/post/migrating-projects-from-dep-to-go-modules">原文地址&lt;/a>&lt;/p>
&lt;p>Go Modules 是 Go 管理的未来方向。已经在 Go 1.11 中可以试用，将会是 Go 1.13 中的默认行为。&lt;/p>
&lt;p>我不会在这篇文章中描述包管理工具的工作流程。我会主要讨论的是如何把现有的项目中 dep 迁移的 Go Module。&lt;/p></description></item><item><title>使用 RMDBS 存储树结构数据</title><link>http://hexiangyu.me/posts/tree-datastruct-in-rmdbs/</link><pubDate>Mon, 25 Mar 2019 22:44:56 +0000</pubDate><guid>http://hexiangyu.me/posts/tree-datastruct-in-rmdbs/</guid><description>&lt;p>在关系型数据库中存储树形结构是比较麻烦的事情，因为数据库都是基于行存储的结构，要满足树形数据结构的添加、删除、查询、修改是一件比较棘手的事情。&lt;/p></description></item><item><title>递归</title><link>http://hexiangyu.me/posts/recursive/</link><pubDate>Sat, 30 Jun 2018 19:26:18 +0000</pubDate><guid>http://hexiangyu.me/posts/recursive/</guid><description>&lt;p>递归（recursion）是数学中处理问题的一种常用方法，在计算机科学中指的是一种通过重复将问题分解为同类的子问题而解决问题的方法。&lt;/p>
&lt;p>换句话说，在处理分治问题上采用递归是一种很简单的方法，其强大描述能力，可以把无限过程表达在有限语句中。&lt;/p></description></item><item><title>Python 如何传递运算表达式</title><link>http://hexiangyu.me/posts/pass-operation-expression/</link><pubDate>Mon, 02 Apr 2018 23:54:25 +0000</pubDate><guid>http://hexiangyu.me/posts/pass-operation-expression/</guid><description>&lt;p>首先要说明的一下，所描述的是 Python 中的 &lt;strong>运算表达式&lt;/strong> 的部分，不是 Python 表达式的部分。&lt;/p>
&lt;p>关于什么是 Python 中的运算表达式，可以参考 Python 文档 &lt;a href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions">10.3.1. Mapping Operators to Functions&lt;/a> 部分，所需要传递的就是这部分运算表达式。&lt;/p></description></item><item><title>Python 优雅地 dumps 非标准类型</title><link>http://hexiangyu.me/posts/python-json-encode/</link><pubDate>Sat, 11 Nov 2017 18:38:29 +0000</pubDate><guid>http://hexiangyu.me/posts/python-json-encode/</guid><description>&lt;p>在 Python 很经常做的一件事就是 Python 数据类型和 JSON 数据类型的转换。&lt;/p>
&lt;p>但是存在一个明显的问题，JSON 作为一种数据交换格式有固定的数据类型，但是 Python 作为编程语言除了内置的数据类型以为还能编写自定义的数据类型。&lt;/p></description></item><item><title>「译」5 种方法构建安全的 Django Admin</title><link>http://hexiangyu.me/posts/5-ways-to-make-django-admin-safer/</link><pubDate>Sat, 17 Jun 2017 16:10:01 +0000</pubDate><guid>http://hexiangyu.me/posts/5-ways-to-make-django-admin-safer/</guid><description>&lt;p>&lt;a href="https://hackernoon.com/5-ways-to-make-django-admin-safer-eb7753698ac8">原文地址&lt;/a>&lt;/p>
&lt;p>拥有越大权限，往往也就责任也越大。Django Admin 在拥有修改权限的同时应该要更加注意安全。&lt;/p>
&lt;p>本文提供了 5 种方法来保护 Django Admin 避免来自认为的错误或者攻击者的攻击。&lt;/p></description></item><item><title>Bottle 源码分析</title><link>http://hexiangyu.me/posts/bottle-source-analysis/</link><pubDate>Sun, 21 May 2017 16:20:12 +0000</pubDate><guid>http://hexiangyu.me/posts/bottle-source-analysis/</guid><description>&lt;p>Bottle 是一个快速，简单和轻量级的 WSGI 微型 Web 框架的 Python。它作为单个文件模块分发，除了 Python 标准库之外没有依赖关系。&lt;/p>
&lt;p>选择源码分析的版本是 Release 于 2009 年 7 月 11 日的 0.4.10 （这是我能找到的最早的发布版本了）。&lt;/p></description></item><item><title>「震惊」你可能需要一个假的 Fetch API</title><link>http://hexiangyu.me/posts/hack-fetch/</link><pubDate>Wed, 29 Mar 2017 16:22:57 +0000</pubDate><guid>http://hexiangyu.me/posts/hack-fetch/</guid><description>&lt;p>Fetch API 已经出现很久了，很多公司和个人都在鼓吹 Fetch 多么牛逼，这点必须要同意。&lt;/p>
&lt;p>Fetch 使用来替代老掉牙的 XMLHttpRequest，XMLHttpRequest 在设计上有着很多缺陷，比如调用方式混乱，不注重分离设计的原则等等，所以后来才会有了类似 JQuery Ajax 之类的库出现。&lt;/p>
&lt;p>首先先给出一个明确的观点，我不否认 Fetch 相反我认为是很优秀的，但是 Fetch API 整体用起来还是有一些不爽的，虽然得益于 Promise 的助攻，但是更多的缺陷也来自 Promise，所以本文就针对基于标准 Promise 实现的 Fetch 吐槽一下用起来的不爽。&lt;/p></description></item><item><title>「译」Python 项目应该都有什么？</title><link>http://hexiangyu.me/posts/what-every-python-project-should-have/</link><pubDate>Mon, 30 Jan 2017 16:24:42 +0000</pubDate><guid>http://hexiangyu.me/posts/what-every-python-project-should-have/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://vladcalin.github.io/what-every-python-project-should-have.html#what-every-python-project-should-have">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Python 语言在过去的几年有着突飞猛进的发展，社区也在快速发展。在发展过程中，社区中出现了许多工具保持着资源的结构性和可获取性。在这篇文章中，我将提供一个简短列表，让每个 Python 项目中都具有可访问性和可维护性。&lt;/p></description></item><item><title>真正的 Tornado 异步非阻塞</title><link>http://hexiangyu.me/posts/real-tornado-async-noblocking/</link><pubDate>Sun, 29 Jan 2017 16:26:41 +0000</pubDate><guid>http://hexiangyu.me/posts/real-tornado-async-noblocking/</guid><description>&lt;p>其中 &lt;strong>Tornado&lt;/strong> 的定义是 Web 框架和异步网络库，其中他具备有异步非阻塞能力，能解决他两个框架请求阻塞的问题，在需要并发能力时候就应该使用 &lt;strong>Tornado&lt;/strong>。&lt;/p>
&lt;p>但是在实际使用过程中很容易把 &lt;strong>Tornado&lt;/strong> 使用成异步阻塞框架，这样对比其他两大框架没有任何优势而言，本文就如何实现真正的异步非阻塞记录。&lt;/p></description></item><item><title>设计模式 —— 抽象工厂模式</title><link>http://hexiangyu.me/posts/abstract-factory-pattern/</link><pubDate>Sun, 18 Dec 2016 16:30:35 +0000</pubDate><guid>http://hexiangyu.me/posts/abstract-factory-pattern/</guid><description>&lt;p>抽象工厂模式的实质是提供「接口」，子类通过实现这些接口来定义具体的操作。&lt;/p>
&lt;p>这些通用的接口如同协议一样，协议本身定义了一系列方法去描述某个类，子类通过实现这些方法从而实现了该类。&lt;/p>
&lt;p>子类中不用关心这个类该是什么样子的，这些都有抽象类去定义，这就区分设计类和实现类两个过程，实现过程的解耦。&lt;/p></description></item><item><title>设计模式 —— 建造者模式</title><link>http://hexiangyu.me/posts/builder-pattern/</link><pubDate>Fri, 16 Dec 2016 16:28:58 +0000</pubDate><guid>http://hexiangyu.me/posts/builder-pattern/</guid><description>&lt;p>建造者模式（生成器模式、Buidler Pattern）和抽象工厂模式的目的都是用来创建复杂的对象，但是创建的过程是截然不同的。&lt;/p></description></item><item><title>namedtuple —— 使用字符串动态生成类</title><link>http://hexiangyu.me/posts/namedtuple-use-string-template/</link><pubDate>Thu, 08 Dec 2016 16:32:00 +0000</pubDate><guid>http://hexiangyu.me/posts/namedtuple-use-string-template/</guid><description>&lt;p>Python 中的 &lt;code>namedtuple&lt;/code> 是一个对 &lt;code>tuple&lt;/code> 的加强机制，返回一个具有命名字段的 &lt;code>tuple&lt;/code> 子类。&lt;/p></description></item><item><title>设计模式 —— 工厂方法</title><link>http://hexiangyu.me/posts/factory-method-pattern/</link><pubDate>Sat, 03 Dec 2016 16:37:36 +0000</pubDate><guid>http://hexiangyu.me/posts/factory-method-pattern/</guid><description>&lt;p>工厂方法是处理不指定对象具体类型情况下创建对象的问题。&lt;/p>
&lt;blockquote>
&lt;p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p>
&lt;/blockquote></description></item><item><title>OrderedDict —— 双向循环列表的最佳实践</title><link>http://hexiangyu.me/posts/ordereddict-double-linked-list/</link><pubDate>Thu, 01 Dec 2016 16:41:26 +0000</pubDate><guid>http://hexiangyu.me/posts/ordereddict-double-linked-list/</guid><description>Python 字典插入操作是无序的，当需要一个有序的字典时需要使用 OrderedDict。
OrderedDict 是继承自 dict 的子类，它具有普通字典的一模一样操作（包括时间复杂度），同时在内部还维护一个 双向循环链表 作为有序化的基础。内部方法中除了，__getitem__, __len__, __contains__ 和 get 之外方法都是具有顺序的。
初始化递归结构和哨兵节点 def __init__(*args, **kwds): &amp;#39;&amp;#39;&amp;#39;初始化一个有序字典，这个签名方法和普通字典一样，但是关键子参数是不被推荐的， 这时候的插入将会是任意的。 &amp;#39;&amp;#39;&amp;#39; if not args: raise TypeError(&amp;#34;descriptor &amp;#39;__init__&amp;#39; of &amp;#39;OrderedDict&amp;#39; object &amp;#34; &amp;#34;needs an argument&amp;#34;) self = args[0] args = args[1:] if len(args) &amp;gt; 1: raise TypeError(&amp;#39;expected at most 1 arguments, got %d&amp;#39; % len(args)) try: self.__root except AttributeError: self.__root = root = [] # 哨兵节点 root[:] = [root, root, None] self.</description></item><item><title>使用 JWT 让你的 RESTful API 更安全</title><link>http://hexiangyu.me/posts/protect-your-restful-api-by-jwt/</link><pubDate>Sat, 26 Nov 2016 16:46:42 +0000</pubDate><guid>http://hexiangyu.me/posts/protect-your-restful-api-by-jwt/</guid><description>&lt;p>传统的 cookie-session 机制可以保证的接口安全，在没有通过认证的情况下会跳转至登入界面或者调用失败。&lt;/p>
&lt;p>在如今 RESTful 化的 API 接口下，cookie-session 已经不能很好发挥其余热保护好你的 API 。&lt;/p>
&lt;p>更多的形式下采用的基于 Token 的验证机制，JWT 本质的也是一种 Token，但是其中又有些许不同。&lt;/p></description></item><item><title>玩玩微信小程序</title><link>http://hexiangyu.me/posts/weapp-github/</link><pubDate>Wed, 05 Oct 2016 16:42:50 +0000</pubDate><guid>http://hexiangyu.me/posts/weapp-github/</guid><description>&lt;p>微信小程序的一次简单尝试——一个&lt;a href="https://github.com/zhengxiaowai/weapp-github">小程序版的 github&lt;/a>&lt;/p></description></item><item><title>「译」Django 的 migtarion 冲突处理</title><link>http://hexiangyu.me/posts/django-migrations-and-how-to-manage-conflicts/</link><pubDate>Mon, 20 Jun 2016 16:51:24 +0000</pubDate><guid>http://hexiangyu.me/posts/django-migrations-and-how-to-manage-conflicts/</guid><description>&lt;p>Migrantion 是 Django 最有用的的特性之一，但是对于我来说改变 Model 这是一个很可怕的任务。尽管能够阅读文档，我仍然很害怕 migration 的冲突或者丢失数据，或者需要手动处理 migration 文件，或者这样那样的事情。事实上，一旦理解它们，migration 是很酷的、很有用的。关于以上的问题你将不会有任何疑问。&lt;/p></description></item><item><title>Django 带数据迁移 Model</title><link>http://hexiangyu.me/posts/django-migrate-model-with-data/</link><pubDate>Wed, 01 Jun 2016 16:49:48 +0000</pubDate><guid>http://hexiangyu.me/posts/django-migrate-model-with-data/</guid><description>&lt;p>Django 的 Model 迁移默认是先删除改表然后在另一个地方创建表，这时候会删除老的表的数据，但是有时候需要带着数据迁移。&lt;/p></description></item><item><title>搬瓦工 Shadowsocks 搭建</title><link>http://hexiangyu.me/posts/use-bandwagonhost-setup-shadowsocks/</link><pubDate>Fri, 01 Apr 2016 16:59:05 +0000</pubDate><guid>http://hexiangyu.me/posts/use-bandwagonhost-setup-shadowsocks/</guid><description>&lt;p>最近好像墙又厚了。。。
Shadowsocks 必须安利一下，利国利民的好东西。&lt;/p></description></item><item><title>使用 Shipyard 搭建 Docker 集群</title><link>http://hexiangyu.me/posts/build-docker-clusters-by-shipyard/</link><pubDate>Tue, 26 Jan 2016 16:47:44 +0000</pubDate><guid>http://hexiangyu.me/posts/build-docker-clusters-by-shipyard/</guid><description>&lt;p>Shipyard 是 docker web ui 的一种，能够可视化操作 docker，可以使用脚本一键搭建，这里主要的问题的 docker hub 被墙的问题。
Shipyard 的安装安装脚本能够自动部署节点和主机连接，方便搭建 docker 的集群环境。&lt;/p></description></item><item><title>设计 RESTful API 指南</title><link>http://hexiangyu.me/posts/restful-api-design/</link><pubDate>Tue, 05 Jan 2016 16:53:23 +0000</pubDate><guid>http://hexiangyu.me/posts/restful-api-design/</guid><description>如今的 web 应用前后端相对的独立了，后端接收和返回一些交互数据，前后端也就这点联系了。。。
那么重点来了，其中的核心就是怎么交互更合理、更方便，更简单。
以前数据交互无非就是 SOAP 和 XML 两种形式，这两个东西写起来和HTML似的一堆标签，看了就恶心。牛逼的 JSON 能和操作字典一样操作数据，省时、省心、省力。所以 REST 使用 JSON 作为数据交互的标准是很合理的。
REST 的全称为 Representational State Transfer， 即是资源的表现层状态转化。作为一种协议而非标准，其强大的结构清晰、符合标准、易于理解、扩展方便的特点得到了广泛的使用。
REST的核心在于资源和转化，就是如何把资源进行转化，去设计API接口。一种资源例如 ** /image ** ，可以使用不同的 HTTP 方发对资源进行转化。HTTP 中有GET、POST、PUT、PATCH、DELETE、OPTION、HEAD等方法。利用这些方法对资源进行配置。
同一种资源 REST 设计中最核心莫过于同一种资源 。例如**/image**，在浏览器中可以通过www.domain.com/image访问该资源。
通过不同的请求方法实现增删改查
获取 通过GET方法获取图片:
GET www.domain.com/image 删除 通过DELETE方法删除图片
DELETE www.domain.com/image 添加 通过POST方法在数据库中添加一个图片:
POST www.domain.com/image Request (application/json) { &amp;#34;imageName&amp;#34; : &amp;#34;xxx.png&amp;#34;, &amp;#34;imageData&amp;#34; : &amp;#34;base64 Code&amp;#34; } Response 200 (application/json) { &amp;#34;imageId&amp;#34; : 1 } 修改 PATCH www.domain.com/image Request (application/json) { &amp;#34;imageId&amp;#34; : 1, &amp;#34;imageData&amp;#34; : &amp;#34;new base64 Code&amp;#34; } Response 200 (application/json) { &amp;#34;isOK&amp;#34; : true } URL设计 URL 作为互联网中对服务器的唯一入口，一个好的 URL 可以很明确定位出这个 URL 是干嘛用的。</description></item><item><title>CSS 设计指南读书笔记</title><link>http://hexiangyu.me/posts/css-designer-guide/</link><pubDate>Sun, 01 Nov 2015 16:39:51 +0000</pubDate><guid>http://hexiangyu.me/posts/css-designer-guide/</guid><description>剖析CSS规则 给文档添加样式的方法有三种：行内样式、嵌入样式、链接样式。
行内样式
直接写在属性里：
&amp;lt;p style=&amp;#34;font-size: 14px; color: red;&amp;#34;&amp;gt;我是一个内容&amp;lt;/p&amp;gt; 行内样式只能影响所在的标签，而且还会覆盖嵌入样式和链接样式。
嵌入样式
写在 style 标签中：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; h1 {font-size: 15px;} p {color: red;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;我是h1标签&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;我是p标签&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 嵌入样式只适用于当前页面，会覆盖链接样式，同时会被行内样式覆盖。
链接样式
写在 link 标签中：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;css/style.css&amp;#34;&amp;gt; 链接样式适用于全部网站，前提是要把他引入。会被行内样式和嵌入样式覆盖，同时会被下一个链接样式覆盖。
CSS命名规则 CSS的规则由选择符和声明符两部分组成。
p {color: red;} p 是选择符，选择了p标签 {color: red;} 是声明符 选择符可以有：
上下文选择符 ID和类选择符 属性选择符 声明符由三部分组成：
{ } 花括号包围 color 标签的一个属性 red 属性的一个值 有三种使用方法：
一条规则多个声明 p { color: red; font-size: 14px; font-weight: bold; } 多个属性选择符共用某些属性 h1 h2 h3 { color: red; font-size: 14px; font-weight: bold; } 对一个属性设置多次 h1 h2 h3 { color: red; font-size: 14px; font-weight: bold; } h3 {font-style: italic;} 上下文选择符 格式：标签1 标签2 {声明}</description></item><item><title>《Python 高级编程》读书笔记</title><link>http://hexiangyu.me/posts/expert-python-programming/</link><pubDate>Sat, 01 Aug 2015 16:54:46 +0000</pubDate><guid>http://hexiangyu.me/posts/expert-python-programming/</guid><description>列表推导 在Python中总是要透着一种极简主义，这样才能显示出Python牛逼哄哄。所以Python语法中总是能写的短就写的短，这是Python的精髓。
列表推导就是为了简化列表生成，换一种说法就是用一行代码生成复杂的列表。
在C语言中你要生成一个0~100中偶数构成的数组你只能这么写：
int array[50] = {}; for(int i = 0; i &amp;lt; 100; i++) { if(0 == i % 2) array[i] = i; } 一共用了5行，当然更多时候是6行。
Python也有这种土逼的写法，当然也有更牛逼的写法，你可以这样写：
[i for i in xrange(100) if (i % 2) is 0] Python的enmuerate内建函数十分有用，不仅能取元素还可以取序号
&amp;gt;&amp;gt;&amp;gt; l = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] &amp;gt;&amp;gt;&amp;gt; for i, e in enumerate(l): ... print &amp;#34;{0} : {1}&amp;#34;.format(i,e) ... 0 : a 1 : b 2 : c 3 : d &amp;gt;&amp;gt;&amp;gt; 结合列表推导，可以写出很简洁的代码：</description></item></channel></rss>